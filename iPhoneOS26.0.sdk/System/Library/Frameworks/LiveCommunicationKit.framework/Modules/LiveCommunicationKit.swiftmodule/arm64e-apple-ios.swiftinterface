// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 (swiftlang-6.2.0.17.14 clang-1700.3.17.1)
// swift-module-flags: -target arm64e-apple-ios26.0 -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -user-module-version 104.100.1.2.29 -module-name LiveCommunicationKit
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import AVFoundation
import Combine
import ExtensionFoundation
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class PauseConversationAction : LiveCommunicationKit.ConversationAction {
  final public let isPaused: Swift.Bool
  public init(conversationUUID: Foundation.UUID, isPaused: Swift.Bool)
  @objc deinit
}
prefix operator >>
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.ConversationManager {
  @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
  @available(tvOS, unavailable)
  public struct Configuration {
    public var ringtoneName: Swift.String?
    public var iconTemplateImageData: Foundation.Data?
    public var maximumConversationGroups: Swift.Int
    public var maximumConversationsPerConversationGroup: Swift.Int
    public var includesConversationInRecents: Swift.Bool
    public var supportsVideo: Swift.Bool
    public var supportedHandleTypes: Swift.Set<LiveCommunicationKit.Handle.Kind>
    @available(iOS 26.0, *)
    public var supportsAudioTranslation: Swift.Bool
    #if compiler(>=5.3) && $NonescapableTypes
    public init(ringtoneName: Swift.String?, iconTemplateImageData: Foundation.Data?, maximumConversationGroups: Swift.Int, maximumConversationsPerConversationGroup: Swift.Int, includesConversationInRecents: Swift.Bool, supportsVideo: Swift.Bool, supportedHandleTypes: Swift.Set<LiveCommunicationKit.Handle.Kind>)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init(ringtoneName: Swift.String?, iconTemplateImageData: Foundation.Data?, maximumConversationGroups: Swift.Int, maximumConversationsPerConversationGroup: Swift.Int, includesConversationInRecents: Swift.Bool, supportsVideo: Swift.Bool, supportedHandleTypes: Swift.Set<LiveCommunicationKit.Handle.Kind>, supportsAudioTranslation: Swift.Bool)
    #endif
  }
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class Conversation : Swift.Sendable {
  final public let uuid: Foundation.UUID
  final public var state: LiveCommunicationKit.Conversation.State {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var localMember: LiveCommunicationKit.Handle? {
    get
  }
  #endif
  @objc deinit
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
extension LiveCommunicationKit.Conversation : nonisolated Observation.Observable {
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
open class ConversationAction {
  final public var uuid: Foundation.UUID {
    get
  }
  final public var conversationUUID: Foundation.UUID {
    get
  }
  final public var state: LiveCommunicationKit.ConversationAction.State {
    get
  }
  final public var timeoutDate: Foundation.Date {
    get
  }
  convenience public init(conversationUUID: Foundation.UUID, timeoutDate: Foundation.Date = Date(timeIntervalSinceNow: 30))
  final public func fulfill()
  final public func fail()
  @objc deinit
}
@available(iOS 26.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct StartCellularConversationAction : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public init(_ recentConversation: LiveCommunicationKit.ConversationHistoryManager.RecentConversation)
  #if compiler(>=5.3) && $NonescapableTypes
  public init(_ handle: LiveCommunicationKit.Handle, cellularService: LiveCommunicationKit.CellularService? = nil)
  #endif
  public static func == (a: LiveCommunicationKit.StartCellularConversationAction, b: LiveCommunicationKit.StartCellularConversationAction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct CellularService : Swift.Identifiable, Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let id: Foundation.UUID
  public let label: Swift.String
  public static func == (a: LiveCommunicationKit.CellularService, b: LiveCommunicationKit.CellularService) -> Swift.Bool
  @available(iOS 26.0, *)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
final public class TelephonyConversationManager : Swift.Sendable {
  public static let sharedInstance: LiveCommunicationKit.TelephonyConversationManager
  final public var cellularServices: [LiveCommunicationKit.CellularService] {
    get
  }
  final public func startCellularConversation(_ action: LiveCommunicationKit.StartCellularConversationAction) async throws
  @objc deinit
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation {
  public enum State : Swift.Int, Swift.Sendable, Swift.Codable, Swift.Hashable {
    case idle
    case joining
    case joined
    case paused
    case leaving
    case left
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, macOS 26.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class StartConversationAction : LiveCommunicationKit.ConversationAction {
  final public let handles: [LiveCommunicationKit.Handle]
  final public let isVideo: Swift.Bool
  public init(conversationUUID: Foundation.UUID, handles: [LiveCommunicationKit.Handle], isVideo: Swift.Bool)
  final public func fulfill(dateStarted: Foundation.Date)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class MergeConversationAction : LiveCommunicationKit.ConversationAction {
  final public let conversationUUIDToMergeWith: Foundation.UUID
  public init(conversationUUID: Foundation.UUID, conversationUUIDToMergeWith: Foundation.UUID)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class ConversationManager {
  final public var conversations: [LiveCommunicationKit.Conversation] {
    get
  }
  weak final public var delegate: (any LiveCommunicationKit.ConversationManagerDelegate)?
  final public let configuration: LiveCommunicationKit.ConversationManager.Configuration
  final public var pendingActions: [LiveCommunicationKit.ConversationAction] {
    get
  }
  convenience public init(configuration: LiveCommunicationKit.ConversationManager.Configuration)
  final public func perform(_ actions: [LiveCommunicationKit.ConversationAction]) async throws
  final public func reportNewIncomingConversation(uuid: Foundation.UUID, update: LiveCommunicationKit.Conversation.Update) async throws
  final public func reportConversationEvent(_ event: LiveCommunicationKit.Conversation.Event, for conversation: LiveCommunicationKit.Conversation)
  final public class func reportNewIncomingVoIPPushPayload(_ payload: [Swift.AnyHashable : Any]) async throws
  final public func invalidate()
  final public func pendingConversationActions(of conversationActionClass: LiveCommunicationKit.ConversationAction.Type, for conversation: LiveCommunicationKit.Conversation) -> [LiveCommunicationKit.ConversationAction]
  @objc deinit
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
extension LiveCommunicationKit.ConversationManager : nonisolated Observation.Observable {
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, *)
final public class SetTranslatingAction : LiveCommunicationKit.ConversationAction {
  final public let isTranslating: Swift.Bool
  final public let localLanguage: Foundation.Locale.Language
  final public let remoteLanguage: Foundation.Locale.Language
  public enum TranslationEngine {
    case `default`
    case custom
    public static func == (a: LiveCommunicationKit.SetTranslatingAction.TranslationEngine, b: LiveCommunicationKit.SetTranslatingAction.TranslationEngine) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(conversationID: Foundation.UUID, isTranslating: Swift.Bool, localLanguage: Foundation.Locale.Language, remoteLanguage: Foundation.Locale.Language)
  final public func fulfill(using translationEngine: LiveCommunicationKit.SetTranslatingAction.TranslationEngine)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class JoinConversationAction : LiveCommunicationKit.ConversationAction {
  public init(conversationUUID: Foundation.UUID)
  final public func fulfill(dateConnected: Foundation.Date)
  @objc deinit
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation {
  public enum Event : Swift.Sendable, Swift.Codable, Swift.Hashable {
    case conversationUpdated(LiveCommunicationKit.Conversation.Update)
    case conversationStartedConnecting(Foundation.Date)
    case conversationConnected(Foundation.Date)
    case conversationEnded(Foundation.Date, LiveCommunicationKit.Conversation.EndedReason)
    public static func == (a: LiveCommunicationKit.Conversation.Event, b: LiveCommunicationKit.Conversation.Event) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
public protocol ConversationManagerDelegate : AnyObject {
  func conversationManager(_ manager: LiveCommunicationKit.ConversationManager, conversationChanged conversation: LiveCommunicationKit.Conversation)
  func conversationManagerDidBegin(_ manager: LiveCommunicationKit.ConversationManager)
  func conversationManagerDidReset(_ manager: LiveCommunicationKit.ConversationManager)
  func conversationManager(_ manager: LiveCommunicationKit.ConversationManager, perform action: LiveCommunicationKit.ConversationAction)
  func conversationManager(_ manager: LiveCommunicationKit.ConversationManager, timedOutPerforming action: LiveCommunicationKit.ConversationAction)
  func conversationManager(_ manager: LiveCommunicationKit.ConversationManager, didActivate audioSession: AVFAudio.AVAudioSession)
  func conversationManager(_ manager: LiveCommunicationKit.ConversationManager, didDeactivate audioSession: AVFAudio.AVAudioSession)
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation {
  public struct Update : Swift.Sendable, Swift.Codable, Swift.Hashable {
    #if compiler(>=5.3) && $NonescapableTypes
    public var localMember: LiveCommunicationKit.Handle? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var members: Swift.Set<LiveCommunicationKit.Handle>? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var activeRemoteMembers: Swift.Set<LiveCommunicationKit.Handle>? {
      get
      set
    }
    #endif
    public var capabilities: LiveCommunicationKit.Conversation.Capabilities?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(localMember: LiveCommunicationKit.Handle? = nil, members: Swift.Set<LiveCommunicationKit.Handle>? = nil, activeRemoteMembers: Swift.Set<LiveCommunicationKit.Handle>? = nil, capabilities: LiveCommunicationKit.Conversation.Capabilities? = nil)
    #endif
    public static func == (a: LiveCommunicationKit.Conversation.Update, b: LiveCommunicationKit.Conversation.Update) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class PlayToneAction : LiveCommunicationKit.ConversationAction {
  public enum Tone : Swift.Int, @unchecked Swift.Sendable {
    case single
    case softPause
    case hardPause
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  final public let digits: Swift.String
  final public let tone: LiveCommunicationKit.PlayToneAction.Tone
  public init(conversationUUID: Foundation.UUID, digits: Swift.String, tone: LiveCommunicationKit.PlayToneAction.Tone)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class EndConversationAction : LiveCommunicationKit.ConversationAction {
  public init(conversationUUID: Foundation.UUID)
  final public func fulfill(dateEnded: Foundation.Date)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class UnmergeConversationAction : LiveCommunicationKit.ConversationAction {
  public init(conversationUUID: Foundation.UUID)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
final public class ConversationHistoryManager : Swift.Sendable {
  public static let sharedInstance: LiveCommunicationKit.ConversationHistoryManager
  final public func recentConversations(matching request: Foundation.Predicate<LiveCommunicationKit.ConversationHistoryManager.RecentConversation>) async throws -> [LiveCommunicationKit.ConversationHistoryManager.RecentConversation]
  final public func markConversationsAsRead(_ recentConversations: [LiveCommunicationKit.ConversationHistoryManager.RecentConversation]) async throws
  final public func markConversationAsRead(_ recentConversation: LiveCommunicationKit.ConversationHistoryManager.RecentConversation) async throws
  @objc deinit
}
@available(iOS 26.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension LiveCommunicationKit.ConversationHistoryManager {
  public struct RecentConversation : Swift.Identifiable, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public enum Status : Swift.Codable, Swift.Hashable, Swift.Sendable {
      case connected
      case missed
      case answeredElsewhere
      case cancelled
      case unknown
      public static func == (a: LiveCommunicationKit.ConversationHistoryManager.RecentConversation.Status, b: LiveCommunicationKit.ConversationHistoryManager.RecentConversation.Status) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public enum Direction : Swift.Codable, Swift.Hashable, Swift.Sendable {
      case outgoing
      case incoming
      public static func == (a: LiveCommunicationKit.ConversationHistoryManager.RecentConversation.Direction, b: LiveCommunicationKit.ConversationHistoryManager.RecentConversation.Direction) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public let id: Foundation.UUID
    public let handles: [LiveCommunicationKit.Handle]
    public let date: Foundation.Date
    public let duration: Foundation.TimeInterval
    public let status: LiveCommunicationKit.ConversationHistoryManager.RecentConversation.Status
    public let direction: LiveCommunicationKit.ConversationHistoryManager.RecentConversation.Direction
    public let isRead: Swift.Bool
    public static func == (a: LiveCommunicationKit.ConversationHistoryManager.RecentConversation, b: LiveCommunicationKit.ConversationHistoryManager.RecentConversation) -> Swift.Bool
    @available(iOS 26.0, *)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    @available(macOS, unavailable)
    public typealias ID = Foundation.UUID
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ConversationHistoryDidUpdate : Foundation.NotificationCenter.AsyncMessage {
    public typealias Subject = LiveCommunicationKit.ConversationHistoryManager
    public static var name: Foundation.Notification.Name {
      get
    }
    public init()
    #if compiler(>=5.3) && $NonescapableTypes
    public static func makeMessage(_ notification: Foundation.Notification) -> LiveCommunicationKit.ConversationHistoryManager.ConversationHistoryDidUpdate?
    #endif
  }
}
@available(iOS 26.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<LiveCommunicationKit.ConversationHistoryManager.ConversationHistoryDidUpdate> {
  public static var conversationHistoryDidUpdateMessage: Foundation.NotificationCenter.BaseMessageIdentifier<LiveCommunicationKit.ConversationHistoryManager.ConversationHistoryDidUpdate> {
    get
  }
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation {
  @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
  @available(tvOS, unavailable)
  public enum EndedReason : Swift.Int, Swift.Sendable, Swift.Codable, Swift.Hashable {
    case failed
    case remoteEnded
    case unanswered
    case joinedElsewhere
    case declinedElsewhere
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation {
  public struct Capabilities : Swift.OptionSet, Swift.Sendable, Swift.Codable, Swift.Hashable {
    public static let pausing: LiveCommunicationKit.Conversation.Capabilities
    public static let merging: LiveCommunicationKit.Conversation.Capabilities
    public static let unmerging: LiveCommunicationKit.Conversation.Capabilities
    public static let video: LiveCommunicationKit.Conversation.Capabilities
    public static let playingTones: LiveCommunicationKit.Conversation.Capabilities
    public var rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias ArrayLiteralElement = LiveCommunicationKit.Conversation.Capabilities
    @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias Element = LiveCommunicationKit.Conversation.Capabilities
    @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias RawValue = Swift.Int
  }
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.ConversationAction {
  public enum State : Swift.Sendable, Swift.Codable, Swift.Hashable {
    case idle
    case running
    case complete
    case failed(reason: Swift.String)
    public static func == (a: LiveCommunicationKit.ConversationAction.State, b: LiveCommunicationKit.ConversationAction.State) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
public struct Handle : Swift.Sendable, Swift.Codable, Swift.Hashable {
  public enum Kind : Swift.Int, Swift.Sendable, Swift.Codable, Swift.Hashable {
    case generic
    case phoneNumber
    case emailAddress
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var type: LiveCommunicationKit.Handle.Kind
  public var value: Swift.String
  public var displayName: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public init(type: LiveCommunicationKit.Handle.Kind, value: Swift.String, displayName: Swift.String? = nil)
  #endif
  public static func == (a: LiveCommunicationKit.Handle, b: LiveCommunicationKit.Handle) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
final public class MuteConversationAction : LiveCommunicationKit.ConversationAction {
  final public let isMuted: Swift.Bool
  public init(conversationUUID: Foundation.UUID, isMuted: Swift.Bool)
  @objc deinit
}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation.State : Swift.RawRepresentable {}
@available(iOS 26.0, *)
extension LiveCommunicationKit.SetTranslatingAction.TranslationEngine : Swift.Equatable {}
@available(iOS 26.0, *)
extension LiveCommunicationKit.SetTranslatingAction.TranslationEngine : Swift.Hashable {}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.PlayToneAction.Tone : Swift.Equatable {}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.PlayToneAction.Tone : Swift.Hashable {}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.PlayToneAction.Tone : Swift.RawRepresentable {}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension LiveCommunicationKit.Conversation.EndedReason : Swift.RawRepresentable {}
@available(iOS 17.4, watchOS 10.4, visionOS 1.1, macCatalyst 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
extension LiveCommunicationKit.Handle.Kind : Swift.RawRepresentable {}
