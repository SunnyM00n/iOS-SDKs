// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 (swiftlang-6.2.0.17.14 clang-1700.3.17.1)
// swift-module-flags: -target arm64e-apple-ios26.0 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftCoreMedia -swift-version 6 -enforce-exclusivity=checked -O -library-level api -enable-upcoming-feature InternalImportsByDefault -enable-upcoming-feature MemberImportVisibility -enable-experimental-feature DebugDescriptionMacro -user-module-version 3255.79.1.8 -module-name CoreMedia
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
public import CoreAudio
public import CoreAudioTypes
public import CoreFoundation
@_exported public import CoreMedia
public import CoreVideo
public import Darwin
public import Dispatch
public import Foundation
public import Swift
public import _Concurrency
public import _StringProcessing
public import _SwiftConcurrencyShims
public import simd
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMInitTrampoline<T> {
  associatedtype T : AnyObject
  init(referencing: Self.T)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMObjectiveCBridgeableWithRawValue : Swift.Hashable, Swift.RawRepresentable, Swift._ObjectiveCBridgeable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMObjectiveCBridgeableWithRawValue where Self.RawValue : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMObjectiveCBridgeableWithRawValue where Self.RawValue == CoreFoundation.CFString, Self._ObjectiveCType == CoreFoundation.CFString {
  public func _bridgeToObjectiveC() -> Self._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType?) -> Self
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMObjectiveCBridgeableWithRawValue where Self.RawValue : Swift._ObjectiveCBridgeable, Self._ObjectiveCType == Self.RawValue._ObjectiveCType {
  public func _bridgeToObjectiveC() -> Self._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType?) -> Self
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMClock {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let missingRequiredParameter: Foundation.NSError
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let unsupportedOperation: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTimebase {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let missingRequiredParameter: Foundation.NSError
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let timerIntervalTooShort: Foundation.NSError
    public static let readOnly: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public struct CMSync : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSync {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let missingRequiredParameter: Foundation.NSError
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let rateMustBeNonZero: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMClock {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static var hostTimeClock: CoreMedia.CMClock {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static func convertHostTimeToSystemUnits(_ hostTime: CoreMedia.CMTime) -> Swift.UInt64
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static func convertSystemUnitsToHostTime(_ systemUnits: Swift.UInt64) -> CoreMedia.CMTime
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var time: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func anchorTime() throws -> (anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func mightDrift(relativeTo otherClock: CoreMedia.CMClock) -> Swift.Bool
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func invalidate()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMTimebaseInitTrampoline : CoreMedia._CMInitTrampoline where Self.T == CoreMedia.CMTimebase {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMTimebaseInitTrampoline {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
  public init(sourceClock: CoreMedia.CMClock) throws
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "init(sourceClock:)")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceClock:)")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceClock:)")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "init(sourceClock:)")
  public init(masterClock: CoreMedia.CMClock) throws
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
  public init(sourceTimebase: CoreMedia.CMTimebase) throws
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "init(sourceTimebase:)")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceTimebase:)")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceTimebase:)")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "init(sourceTimebase:)")
  public init(masterTimebase: CoreMedia.CMTimebase) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTimebase : CoreMedia._CMTimebaseInitTrampoline {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias T = CoreMedia.CMTimebase
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTimebase {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
  public var sourceTimebase: CoreMedia.CMTimebase? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "sourceTimebase")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceTimebase")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceTimebase")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "sourceTimebase")
  public var masterTimebase: CoreMedia.CMTimebase? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
  public var sourceClock: CoreMedia.CMClock? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "sourceClock")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceClock")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceClock")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "sourceClock")
  public var masterClock: CoreMedia.CMClock? {
    get
  }
  #endif
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
  public var source: any CoreMedia.CMSyncProtocol {
    get
    set
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "source")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "source")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "source")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "source")
  public var master: any CoreMedia.CMSyncProtocol {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
  public var ultimateSourceClock: CoreMedia.CMClock {
    get
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "ultimateSourceClock")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "ultimateSourceClock")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "ultimateSourceClock")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "ultimateSourceClock")
  public var ultimateMasterClock: CoreMedia.CMClock {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var time: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func time(withTimescale timescale: CoreMedia.CMTimeScale, rounding: CoreMedia.CMTimeRoundingMethod = .`default`) -> CoreMedia.CMTime
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setTime(_ time: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setAnchorTime(_ anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var rate: Swift.Double {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var timeAndRate: (time: CoreMedia.CMTime, rate: Swift.Double) {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setRate(_ rate: Swift.Double) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setRateAndAnchorTime(rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var effectiveRate: Swift.Double {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func addTimer(_ timer: Foundation.Timer, on runloop: Foundation.RunLoop) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static let veryLongTimeInterval: CoreFoundation.CFTimeInterval
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static let farFuture: CoreFoundation.CFAbsoluteTime
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func removeTimer(_ timer: Foundation.Timer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setTimerNextFireTime(_ timer: Foundation.Timer, fireTime: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setTimerToFireImmediately(_ timer: Foundation.Timer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func addTimer<T>(_ timer: T) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func removeTimer<T>(_ timer: T) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setTimerNextFireTime<T>(_ timer: T, fireTime: CoreMedia.CMTime) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setTimerToFireImmediately<T>(_ timer: T) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func notificationBarrier() throws
}
@available(macOS, introduced: 10.8, deprecated: 12.0, renamed: "CMTimebaseSetAnchorTime(_:timebaseTime:immediateSourceTime:)")
@available(iOS, introduced: 6.0, deprecated: 15.0, renamed: "CMTimebaseSetAnchorTime(_:timebaseTime:immediateSourceTime:)")
@available(tvOS, introduced: 9.0, deprecated: 15.0, renamed: "CMTimebaseSetAnchorTime(_:timebaseTime:immediateSourceTime:)")
@available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "CMTimebaseSetAnchorTime(_:timebaseTime:immediateSourceTime:)")
@_alwaysEmitIntoClient public func CMTimebaseSetAnchorTime(_ timebase: CoreMedia.CMTimebase, timebaseTime: CoreMedia.CMTime, immediateMasterTime: CoreMedia.CMTime) {
	CMTimebaseSetAnchorTime(timebase, timebaseTime:timebaseTime, immediateSourceTime:immediateMasterTime)
}
@available(macOS, introduced: 10.8, deprecated: 12.0, renamed: "CMTimebaseSetRateAndAnchorTime(_:rate:anchorTime:immediateSourceTime:)")
@available(iOS, introduced: 6.0, deprecated: 15.0, renamed: "CMTimebaseSetRateAndAnchorTime(_:rate:anchorTime:immediateSourceTime:)")
@available(tvOS, introduced: 9.0, deprecated: 15.0, renamed: "CMTimebaseSetRateAndAnchorTime(_:rate:anchorTime:immediateSourceTime:)")
@available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "CMTimebaseSetRateAndAnchorTime(_:rate:anchorTime:immediateSourceTime:)")
@_alwaysEmitIntoClient public func CMTimebaseSetRateAndAnchorTime(_ timebase: CoreMedia.CMTimebase, rate: Swift.Double, anchorTime: CoreMedia.CMTime, immediateMasterTime: CoreMedia.CMTime) {
	CMTimebaseSetRateAndAnchorTime(timebase, rate: rate, anchorTime:anchorTime, immediateSourceTime:immediateMasterTime)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTimebase {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static let effectiveRateChanged: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static let timeJumped: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct NotificationKey : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
    public typealias RawValue = CoreFoundation.CFString
    public typealias _ObjectiveCType = CoreFoundation.CFString
    public var rawValue: CoreFoundation.CFString
    public init(rawValue: CoreFoundation.CFString)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
    public static let eventTime: CoreMedia.CMTimebase.NotificationKey
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol CMSyncProtocol : Swift.Sendable {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  func rate<T>(relativeTo clockOrTimebase: T) -> Swift.Double where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  func rateAndAnchorTime<T>(relativeTo clockOrTimebase: T) throws -> (rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  func convertTime<T>(_ time: CoreMedia.CMTime, to clockOrTimebase: T) -> CoreMedia.CMTime where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  func mightDrift<T>(relativeTo clockOrTimebase: T) -> Swift.Bool where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  var time: CoreMedia.CMTime { get }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTimebase : CoreMedia.CMSyncProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func rate<T>(relativeTo relativeToClockOrTimebase: T) -> Swift.Double where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func rateAndAnchorTime<T>(relativeTo clockOrTimebase: T) throws -> (rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func convertTime<T>(_ time: CoreMedia.CMTime, to clockOrTimebase: T) -> CoreMedia.CMTime where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func mightDrift<T>(relativeTo clockOrTimebase: T) -> Swift.Bool where T : CoreMedia.CMSyncProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMClock : CoreMedia.CMSyncProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func rate<T>(relativeTo relativeToClockOrTimebase: T) -> Swift.Double where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func rateAndAnchorTime<T>(relativeTo clockOrTimebase: T) throws -> (rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func convertTime<T>(_ time: CoreMedia.CMTime, to clockOrTimebase: T) -> CoreMedia.CMTime where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func mightDrift<T>(relativeTo clockOrTimebase: T) -> Swift.Bool where T : CoreMedia.CMSyncProtocol
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
public struct CMTaggedBuffer : Swift.CustomStringConvertible {
  public enum Buffer {
    case sampleBuffer(CoreMedia.CMSampleBuffer)
    case pixelBuffer(CoreVideo.CVPixelBuffer)
  }
  public let tags: [CoreMedia.CMTag]
  public let buffer: CoreMedia.CMTaggedBuffer.Buffer
  public init(tags: [CoreMedia.CMTag], buffer: CoreMedia.CMTaggedBuffer.Buffer)
  public init(tags: [CoreMedia.CMTag], sampleBuffer: CoreMedia.CMSampleBuffer)
  public init(tags: [CoreMedia.CMTag], pixelBuffer: CoreVideo.CVPixelBuffer)
  public var description: Swift.String {
    get
  }
}
@available(*, unavailable)
extension CoreMedia.CMTaggedBuffer : Swift.Sendable {
}
@available(*, unavailable)
extension CoreMedia.CMTaggedBuffer.Buffer : Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer {
  public var contentType: CoreMedia.CMSampleBuffer.ContentType {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public struct CMTaggedDynamicBuffer : Swift.Sendable {
  public enum Content : Swift.Sendable {
    case pixelBuffer(CoreVideo.CVReadOnlyPixelBuffer)
    case pixelSampleBuffer(CoreMedia.CMReadySampleBuffer<CoreVideo.CVReadOnlyPixelBuffer>)
    case dataSampleBuffer(CoreMedia.CMReadySampleBuffer<CoreMedia.CMReadOnlyDataBlockBuffer>)
  }
  public var tags: [CoreMedia.CMTag]
  public var content: CoreMedia.CMTaggedDynamicBuffer.Content
  public init(tags: [CoreMedia.CMTag], content: CoreMedia.CMTaggedDynamicBuffer.Content)
  public init(tags: [CoreMedia.CMTag], content: CoreVideo.CVReadOnlyPixelBuffer)
  public init(tags: [CoreMedia.CMTag], content: CoreMedia.CMReadySampleBuffer<CoreVideo.CVReadOnlyPixelBuffer>)
  public init(tags: [CoreMedia.CMTag], content: CoreMedia.CMReadySampleBuffer<CoreMedia.CMReadOnlyDataBlockBuffer>)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMTaggedDynamicBuffer {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeBuffer: sending CoreMedia.CMTaggedBuffer)
  #else
  public init(unsafeBuffer: __owned CoreMedia.CMTaggedBuffer)
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withUnsafeTaggedBuffer<R>(_ body: (CoreMedia.CMTaggedBuffer) throws -> sending R) rethrows -> sending R
  #else
  public func withUnsafeTaggedBuffer<R>(_ body: (CoreMedia.CMTaggedBuffer) throws -> R) rethrows -> R
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.Array where Element == CoreMedia.CMTaggedDynamicBuffer {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withUnsafeTaggedBuffers<R>(_ body: ([CoreMedia.CMTaggedBuffer]) throws -> sending R) rethrows -> sending R where R : ~Copyable
  #else
  public func withUnsafeTaggedBuffers<R>(_ body: ([CoreMedia.CMTaggedBuffer]) throws -> R) rethrows -> R where R : ~Copyable
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public struct CMReadySampleBuffer<Content> : Swift.Sendable where Content : CoreMedia.CMSampleBuffer.Content {
  public var contentType: CoreMedia.CMSampleBuffer.ContentType {
    get
  }
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withUnsafeSampleBuffer<R>(_ body: (CoreMedia.CMSampleBuffer) throws -> sending R) rethrows -> sending R where R : ~Copyable
  #else
  public func withUnsafeSampleBuffer<R>(_ body: (CoreMedia.CMSampleBuffer) throws -> R) rethrows -> R where R : ~Copyable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_disfavoredOverload public var formatDescription: CoreMedia.CMFormatDescription? {
    get
  }
  #endif
  public var duration: CoreMedia.CMTime {
    get
  }
  public var presentationTimeStamp: CoreMedia.CMTime {
    get
  }
  public var decodeTimeStamp: CoreMedia.CMTime {
    get
  }
  public var outputDuration: CoreMedia.CMTime {
    get
  }
  public var outputPresentationTimeStamp: CoreMedia.CMTime {
    get
    set
  }
  public var outputDecodeTimeStamp: CoreMedia.CMTime {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content : CoreMedia.CMSampleBuffer.ContentWithFormatDescription {
  public var formatDescription: CoreMedia.CMFormatDescription {
    get
    set
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content : CoreMedia.CMSampleBuffer.MultiSampleContent {
  public var sampleCount: Swift.Int {
    get
  }
  public var sampleProperties: CoreMedia.CMSampleBuffer.SamplePropertiesCollection {
    get
    _modify
  }
  public var totalSampleSize: Swift.Int {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var outputSampleTimings: CoreMedia.CMSampleBuffer.TimingPerSample? {
    get
  }
  #endif
  public func splitSamples() -> [CoreMedia.CMReadySampleBuffer<Content>]
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public struct CMReadOnlyDataBlockBuffer : Swift.Sendable {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeBlockBuffer: sending CoreMedia.CMBlockBuffer)
  #else
  public init(unsafeBlockBuffer: __owned CoreMedia.CMBlockBuffer)
  #endif
  public init(subBlockCapacity: Swift.Int = 0)
  public init(_ source: consuming CoreMedia.CMMutableDataBlockBuffer)
  public init(_ data: Foundation.Data)
  public init(_ dispatchData: Dispatch.DispatchData)
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withUnsafeBlockBuffer<R>(_ body: (CoreMedia.CMBlockBuffer) throws -> sending R) rethrows -> sending R where R : ~Copyable
  #else
  public func withUnsafeBlockBuffer<R>(_ body: (CoreMedia.CMBlockBuffer) throws -> R) rethrows -> R where R : ~Copyable
  #endif
  public var isContiguous: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> sending R) rethrows -> sending R?
  #else
  public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R?
  #endif
  #endif
  public mutating func append(referenceOf other: CoreMedia.CMReadOnlyDataBlockBuffer, optimizeDepth: Swift.Bool = true)
  public mutating func append(referenceOf other: consuming CoreMedia.CMMutableDataBlockBuffer, optimizeDepth: Swift.Bool = true)
  public static func + (a: CoreMedia.CMReadOnlyDataBlockBuffer, b: CoreMedia.CMReadOnlyDataBlockBuffer) -> CoreMedia.CMReadOnlyDataBlockBuffer
  public static func + (a: CoreMedia.CMReadOnlyDataBlockBuffer, b: consuming CoreMedia.CMMutableDataBlockBuffer) -> CoreMedia.CMReadOnlyDataBlockBuffer
  public static func += (lhs: inout CoreMedia.CMReadOnlyDataBlockBuffer, rhs: CoreMedia.CMReadOnlyDataBlockBuffer)
  public static func += (lhs: inout CoreMedia.CMReadOnlyDataBlockBuffer, rhs: consuming CoreMedia.CMMutableDataBlockBuffer)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadOnlyDataBlockBuffer : Foundation.DataProtocol {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Regions = [CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion]
  public typealias SubSequence = CoreMedia.CMReadOnlyDataBlockBuffer
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public var indices: Swift.Range<Swift.Int> {
    get
  }
  public var regions: [CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion] {
    get
  }
  public subscript(position: CoreMedia.CMReadOnlyDataBlockBuffer.Index) -> Swift.UInt8 {
    get
  }
  public subscript(range: Swift.Range<CoreMedia.CMReadOnlyDataBlockBuffer.Index>) -> CoreMedia.CMReadOnlyDataBlockBuffer {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_disfavoredOverload public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R?
  #endif
  public struct BlockRegion : Foundation.DataProtocol, Foundation.ContiguousBytes {
    public typealias Index = CoreMedia.CMReadOnlyDataBlockBuffer.Index
    public typealias Indices = CoreMedia.CMReadOnlyDataBlockBuffer.Indices
    public typealias Regions = Swift.CollectionOfOne<CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion>
    public let startIndex: Swift.Int
    public var endIndex: Swift.Int {
      get
    }
    public var count: Swift.Int {
      get
    }
    public subscript(position: CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion.Index) -> Swift.UInt8 {
      get
    }
    public var regions: Swift.CollectionOfOne<CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion> {
      get
    }
    public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    #if compiler(>=5.3) && $NonescapableTypes
    public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R?
    #endif
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias Element = Swift.UInt8
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion>
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias SubSequence = Swift.Slice<CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion>
  }
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias Element = Swift.UInt8
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMReadOnlyDataBlockBuffer>
}
@available(*, unavailable)
extension CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion : Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public struct CMMutableDataBlockBuffer : ~Swift.Copyable, Swift.Sendable {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeBlockBuffer: sending CoreMedia.CMBlockBuffer)
  #else
  public init(unsafeBlockBuffer: __owned CoreMedia.CMBlockBuffer)
  #endif
  public struct BlockSource : Swift.Sendable {
    public var allocate: @Sendable (Swift.Int) -> Swift.UnsafeMutableRawBufferPointer
    public var deallocate: @Sendable (Swift.UnsafeMutableRawBufferPointer) -> Swift.Void
    public init(allocate: @escaping @Sendable (Swift.Int) -> Swift.UnsafeMutableRawBufferPointer, deallocate: @escaping @Sendable (Swift.UnsafeMutableRawBufferPointer) -> Swift.Void)
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(count: Swift.Int = 0, blockSource: CoreMedia.CMMutableDataBlockBuffer.BlockSource? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(subBlockCapacity: Swift.Int, blockSource: CoreMedia.CMMutableDataBlockBuffer.BlockSource? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(copying audioBuffers: Swift.UnsafePointer<CoreAudioTypes.AudioBufferList>, blockSource: CoreMedia.CMMutableDataBlockBuffer.BlockSource? = nil)
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withUnsafeBlockBuffer<R>(_ body: (CoreMedia.CMBlockBuffer) throws -> sending R) rethrows -> sending R where R : ~Copyable
  #else
  public func withUnsafeBlockBuffer<R>(_ body: (CoreMedia.CMBlockBuffer) throws -> R) rethrows -> R where R : ~Copyable
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var isContiguous: Swift.Bool {
    get
  }
  public func isRangeContiguous(_ range: Swift.Range<Swift.Int>) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withContiguousStorageIfAvailable<R>(in range: Swift.Range<Swift.Int>? = nil, _ body: (Swift.UnsafeRawBufferPointer) throws -> sending R) rethrows -> sending R?
  #else
  public func withContiguousStorageIfAvailable<R>(in range: Swift.Range<Swift.Int>? = nil, _ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R?
  #endif
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  #if compiler(>=5.3) && $SendingArgsAndResults
  public mutating func withContiguousMutableStorageIfAvailable<R>(in range: Swift.Range<Swift.Int>? = nil, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> sending R) rethrows -> sending R?
  #else
  public mutating func withContiguousMutableStorageIfAvailable<R>(in range: Swift.Range<Swift.Int>? = nil, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R?
  #endif
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func withUnsafeBlockRegions<R>(_ body: ([CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion]) throws -> sending R) rethrows -> sending R
  #else
  public func withUnsafeBlockRegions<R>(_ body: ([CoreMedia.CMReadOnlyDataBlockBuffer.BlockRegion]) throws -> R) rethrows -> R
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  public mutating func withUnsafeMutableBlockRegions<R>(_ body: ([CoreMedia.CMMutableDataBlockBuffer.BlockRegion]) throws -> sending R) rethrows -> sending R
  #else
  public mutating func withUnsafeMutableBlockRegions<R>(_ body: ([CoreMedia.CMMutableDataBlockBuffer.BlockRegion]) throws -> R) rethrows -> R
  #endif
  public func copyBytes<R>(to destination: Swift.UnsafeMutableRawBufferPointer, from range: R) where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func copyBytes(to destination: Swift.UnsafeMutableRawBufferPointer)
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func append(referenceOf other: consuming CoreMedia.CMMutableDataBlockBuffer, range: Swift.Range<Swift.Int>? = nil, optimizeDepth: Swift.Bool = true)
  #endif
  public static func += (lhs: inout CoreMedia.CMMutableDataBlockBuffer, rhs: consuming CoreMedia.CMMutableDataBlockBuffer)
  public mutating func extend(by count: Swift.Int)
  public mutating func replaceSubrange(_ range: Swift.Range<Swift.Int>, with bytes: Swift.UnsafeRawBufferPointer)
  public mutating func replaceAll(with bytes: Swift.UnsafeRawBufferPointer)
  public mutating func replaceSubrange(_ range: Swift.Range<Swift.Int>, with bytes: some DataProtocol)
  public mutating func replaceAll(with bytes: some DataProtocol)
  public mutating func replaceSubrange(_ range: Swift.Range<Swift.Int>, repeating byte: Swift.UInt8)
  public mutating func replaceAll(repeating byte: Swift.UInt8)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMMutableDataBlockBuffer {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public var indices: CoreMedia.CMMutableDataBlockBuffer.Indices {
    get
  }
  public subscript(position: Swift.Int) -> Swift.UInt8 {
    get
    set
  }
  public struct BlockRegion : Foundation.DataProtocol, Foundation.ContiguousBytes {
    public typealias Index = CoreMedia.CMMutableDataBlockBuffer.Index
    public typealias Indices = CoreMedia.CMMutableDataBlockBuffer.Indices
    public typealias Regions = Swift.CollectionOfOne<CoreMedia.CMMutableDataBlockBuffer.BlockRegion>
    public let startIndex: Swift.Int
    public var endIndex: Swift.Int {
      get
    }
    public var count: Swift.Int {
      get
    }
    public subscript(position: CoreMedia.CMMutableDataBlockBuffer.BlockRegion.Index) -> Swift.UInt8 {
      get
      set
    }
    public var regions: Swift.CollectionOfOne<CoreMedia.CMMutableDataBlockBuffer.BlockRegion> {
      get
    }
    public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    public func withUnsafeMutableBytes<ResultType>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias Element = Swift.UInt8
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMMutableDataBlockBuffer.BlockRegion>
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias SubSequence = Swift.Slice<CoreMedia.CMMutableDataBlockBuffer.BlockRegion>
  }
}
@available(*, unavailable)
extension CoreMedia.CMMutableDataBlockBuffer.BlockRegion : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol CMAttachmentBearerProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  var attachments: CoreMedia.CMAttachmentBearerAttachments { get }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public struct CMAttachmentBearerAttachments {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public enum Value {
    case shouldNotPropagate(Any)
    case shouldPropagate(Any)
    public var value: Any {
      get
    }
    public var mode: CoreMedia.CMAttachmentBearerAttachments.Mode {
      get
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public enum Mode : CoreMedia.CMAttachmentMode, Swift.Sendable {
    case shouldNotPropagate
    case shouldPropagate
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: CoreMedia.CMAttachmentMode)
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias RawValue = CoreMedia.CMAttachmentMode
    public var rawValue: CoreMedia.CMAttachmentMode {
      get
    }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(key: Swift.String) -> CoreMedia.CMAttachmentBearerAttachments.Value? {
    get
    set(newValue)
  }
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func removeAll()
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var nonPropagated: [Swift.String : Any] {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var propagated: [Swift.String : Any] {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func merge(_ attachments: [Swift.String : Any], mode: CoreMedia.CMAttachmentBearerAttachments.Mode)
}
@available(*, unavailable)
extension CoreMedia.CMAttachmentBearerAttachments : Swift.Sendable {
}
@available(*, unavailable)
extension CoreMedia.CMAttachmentBearerAttachments.Value : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer : CoreMedia.CMAttachmentBearerProtocol {
  public var attachments: CoreMedia.CMAttachmentBearerAttachments {
    get
    _modify
  }
  public func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer : CoreMedia.CMAttachmentBearerProtocol {
  public var attachments: CoreMedia.CMAttachmentBearerAttachments {
    get
    _modify
  }
  public func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreVideo.CVBuffer : CoreMedia.CMAttachmentBearerProtocol {
  public var attachments: CoreMedia.CMAttachmentBearerAttachments {
    get
    _modify
  }
  public func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer {
  public enum ContentType : Swift.Sendable, Swift.Hashable {
    case markerOnly
    case sampleReference
    case dataBuffer
    case pixelBuffer
    case taggedBuffers
    public static func == (a: CoreMedia.CMSampleBuffer.ContentType, b: CoreMedia.CMSampleBuffer.ContentType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public protocol Content : Swift.Sendable {
  }
  public protocol MultiSampleContent : CoreMedia.CMSampleBuffer.Content {
  }
  public protocol ContentWithFormatDescription : CoreMedia.CMSampleBuffer.Content {
  }
  public enum DynamicContent : Swift.Sendable, CoreMedia.CMSampleBuffer.MultiSampleContent {
    case markerOnly
    case sampleReference(CoreMedia.CMSampleDataReference)
    case dataBuffer(CoreMedia.CMReadOnlyDataBlockBuffer)
    case pixelBuffer(CoreVideo.CVReadOnlyPixelBuffer)
    case taggedBuffers([CoreMedia.CMTaggedDynamicBuffer])
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content == CoreMedia.CMSampleBuffer.DynamicContent {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeBuffer: sending CoreMedia.CMSampleBuffer)
  #else
  public init(unsafeBuffer: __owned CoreMedia.CMSampleBuffer)
  #endif
  public init(_ other: CoreMedia.CMReadySampleBuffer<some CMSampleBuffer.Content>)
  public var content: CoreMedia.CMSampleBuffer.DynamicContent {
    get
    set
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.Never : CoreMedia.CMSampleBuffer.Content {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content == Swift.Never {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeMarkerOnlySampleBuffer unsafeBuffer: sending CoreMedia.CMSampleBuffer)
  #else
  public init(unsafeMarkerOnlySampleBuffer unsafeBuffer: __owned CoreMedia.CMSampleBuffer)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ other: CoreMedia.CMReadySampleBuffer<CoreMedia.CMSampleBuffer.DynamicContent>)
  #endif
  public init(markerAt markerTime: CoreMedia.CMTime, duration: CoreMedia.CMTime = .invalid)
  public var markerTimeStamp: CoreMedia.CMTime {
    get
    set
  }
  public var duration: CoreMedia.CMTime {
    get
    set
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreVideo.CVReadOnlyPixelBuffer : CoreMedia.CMSampleBuffer.ContentWithFormatDescription {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content == CoreVideo.CVReadOnlyPixelBuffer {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeWithPixelBuffer unsafeBuffer: sending CoreMedia.CMSampleBuffer)
  #else
  public init(unsafeWithPixelBuffer unsafeBuffer: __owned CoreMedia.CMSampleBuffer)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ other: CoreMedia.CMReadySampleBuffer<CoreMedia.CMSampleBuffer.DynamicContent>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(pixelBuffer content: Content, formatDescription: CoreMedia.CMVideoFormatDescription? = nil, presentationTimeStamp: CoreMedia.CMTime, duration: CoreMedia.CMTime = .invalid)
  #endif
  public var content: CoreVideo.CVReadOnlyPixelBuffer {
    get
    set
  }
  public var presentationTimeStamp: CoreMedia.CMTime {
    get
    set
  }
  public var duration: CoreMedia.CMTime {
    get
    set
  }
  public var sampleAttachments: CoreMedia.CMSampleBuffer.SampleAttachments {
    get
    set
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMMutableDataBlockBuffer {
  final public class MemoryPool : Swift.Sendable {
    public init(ageOutDuration: Foundation.TimeInterval = 0.5)
    final public func makeBlockBuffer(count: Swift.Int) -> CoreMedia.CMMutableDataBlockBuffer
    final public func makeBlockBuffer(copying audioBuffers: Swift.UnsafePointer<CoreAudioTypes.AudioBufferList>) -> CoreMedia.CMMutableDataBlockBuffer
    final public func flush()
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMSimpleQueueInitTrampoline : CoreMedia._CMInitTrampoline where Self.T == CoreMedia.CMSimpleQueue {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMSimpleQueueInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(capacity: Swift.Int) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSimpleQueue : CoreMedia._CMSimpleQueueInitTrampoline {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias T = CoreMedia.CMSimpleQueue
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSimpleQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let allocationFailed: Foundation.NSError
    public static let requiredParameterMissing: Foundation.NSError
    public static let parameterOutOfRange: Foundation.NSError
    public static let queueIsFull: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSimpleQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func enqueue(_ element: Swift.UnsafeRawPointer) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func dequeue() -> Swift.UnsafeRawPointer?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var head: Swift.UnsafeRawPointer? {
    get
  }
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func reset() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var capacity: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var count: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var fullness: Swift.Float {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public struct CMSampleDataReference : Swift.Sendable, Swift.Hashable, CoreMedia.CMSampleBuffer.MultiSampleContent, CoreMedia.CMSampleBuffer.ContentWithFormatDescription {
  public var containerLocation: Foundation.URL
  public var byteOffset: Swift.Int
  public init(containerLocation: Foundation.URL, byteOffset: Swift.Int)
  public static func == (a: CoreMedia.CMSampleDataReference, b: CoreMedia.CMSampleDataReference) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content == CoreMedia.CMSampleDataReference {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeSampleDataReferenceBuffer unsafeBuffer: sending CoreMedia.CMSampleBuffer)
  #else
  public init(unsafeSampleDataReferenceBuffer unsafeBuffer: __owned CoreMedia.CMSampleBuffer)
  #endif
  public init(sampleDataReference content: Content, formatDescription: CoreMedia.CMFormatDescription, sampleProperties: CoreMedia.CMSampleBuffer.SamplePropertiesCollection)
  public var content: CoreMedia.CMSampleDataReference {
    get
    set
  }
}
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTimeRange {
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public init(start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isValid: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isIndefinite: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isEmpty: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var end: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public func union(_ otherRange: CoreMedia.CMTimeRange) -> CoreMedia.CMTimeRange
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public func intersection(_ otherRange: CoreMedia.CMTimeRange) -> CoreMedia.CMTimeRange
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public func containsTime(_ time: CoreMedia.CMTime) -> Swift.Bool
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public func containsTimeRange(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
}
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIMERANGE_IS_VALID(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIMERANGE_IS_INVALID(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIMERANGE_IS_INDEFINITE(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIMERANGE_IS_EMPTY(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTimeRange : Swift.Equatable {
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func == (range1: CoreMedia.CMTimeRange, range2: CoreMedia.CMTimeRange) -> Swift.Bool
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func != (range1: CoreMedia.CMTimeRange, range2: CoreMedia.CMTimeRange) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension CoreMedia.CMTimeRange : Swift.Hashable {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadOnlyDataBlockBuffer : CoreMedia.CMSampleBuffer.MultiSampleContent, CoreMedia.CMSampleBuffer.ContentWithFormatDescription {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content == CoreMedia.CMReadOnlyDataBlockBuffer {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeWithDataBuffer unsafeBuffer: sending CoreMedia.CMSampleBuffer)
  #else
  public init(unsafeWithDataBuffer unsafeBuffer: __owned CoreMedia.CMSampleBuffer)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ other: CoreMedia.CMReadySampleBuffer<CoreMedia.CMSampleBuffer.DynamicContent>)
  #endif
  public init(dataBuffer content: Content, formatDescription: CoreMedia.CMFormatDescription, sampleProperties: CoreMedia.CMSampleBuffer.SamplePropertiesCollection)
  public init(audioDataBuffer content: Content, formatDescription: CoreMedia.CMAudioFormatDescription, sampleCount: Swift.Int, presentationTimeStamp: CoreMedia.CMTime)
  public init(compressedAudioDataBuffer content: Content, formatDescription: CoreMedia.CMAudioFormatDescription, presentationTimeStamp: CoreMedia.CMTime, packetDescriptions: [CoreAudioTypes.AudioStreamPacketDescription])
  public var content: CoreMedia.CMReadOnlyDataBlockBuffer {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var audioStreamPacketDescriptions: [CoreAudioTypes.AudioStreamPacketDescription]? {
    get
  }
  #endif
  public func copyPCMData(fromRange range: Swift.Range<Swift.Int>, into bufferList: Swift.UnsafeMutablePointer<CoreAudioTypes.AudioBufferList>) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMSampleBufferInitTrampoline : CoreMedia._CMInitTrampoline where Self.T == CoreMedia.CMSampleBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMSampleBufferInitTrampoline {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, formatDescription: CoreMedia.CMFormatDescription?, numSamples: CoreMedia.CMItemCount, sampleTimings: [CoreMedia.CMSampleTimingInfo], sampleSizes: [Swift.Int]) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, dataReady: Swift.Bool = false, formatDescription: CoreMedia.CMFormatDescription?, numSamples: CoreMedia.CMItemCount, sampleTimings: [CoreMedia.CMSampleTimingInfo], sampleSizes: [Swift.Int], makeDataReadyHandler: @escaping CoreMedia.CMSampleBufferMakeDataReadyHandler) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, formatDescription: CoreMedia.CMFormatDescription, numSamples: CoreMedia.CMItemCount, presentationTimeStamp: CoreMedia.CMTime, packetDescriptions: [CoreAudioTypes.AudioStreamPacketDescription]) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, dataReady: Swift.Bool = false, formatDescription: CoreMedia.CMFormatDescription, numSamples: CoreMedia.CMItemCount, presentationTimeStamp: CoreMedia.CMTime, packetDescriptions: [CoreAudioTypes.AudioStreamPacketDescription], makeDataReadyHandler: @escaping CoreMedia.CMSampleBufferMakeDataReadyHandler) throws
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(imageBuffer: CoreVideo.CVImageBuffer, formatDescription: CoreMedia.CMVideoFormatDescription, sampleTiming: CoreMedia.CMSampleTimingInfo) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
  public init(taggedBuffers: [CoreMedia.CMTaggedBuffer], presentationTimeStamp: CoreMedia.CMTime, duration: CoreMedia.CMTime, formatDescription: CoreMedia.CMTaggedBufferGroupFormatDescription)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(imageBuffer: CoreVideo.CVImageBuffer, dataReady: Swift.Bool = false, formatDescription: CoreMedia.CMVideoFormatDescription, sampleTiming: CoreMedia.CMSampleTimingInfo, makeDataReadyHandler: @escaping CoreMedia.CMSampleBufferMakeDataReadyHandler) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(copying sampleBuffer: CoreMedia.CMSampleBuffer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(copying sampleBuffer: CoreMedia.CMSampleBuffer, withNewTiming sampleTimings: [CoreMedia.CMSampleTimingInfo]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(copying sampleBuffer: CoreMedia.CMSampleBuffer, forRange range: Swift.Range<Swift.Int>) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer : CoreMedia._CMSampleBufferInitTrampoline {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias T = CoreMedia.CMSampleBuffer
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let allocationFailed: Foundation.NSError
    public static let requiredParameterMissing: Foundation.NSError
    public static let alreadyHasDataBuffer: Foundation.NSError
    public static let bufferNotReady: Foundation.NSError
    public static let sampleIndexOutOfRange: Foundation.NSError
    public static let bufferHasNoSampleSizes: Foundation.NSError
    public static let bufferHasNoSampleTimingInfo: Foundation.NSError
    public static let arrayTooSmall: Foundation.NSError
    public static let invalidEntryCount: Foundation.NSError
    public static let cannotSubdivide: Foundation.NSError
    public static let sampleTimingInfoInvalid: Foundation.NSError
    public static let invalidMediaTypeForOperation: Foundation.NSError
    public static let invalidSampleData: Foundation.NSError
    public static let invalidMediaFormat: Foundation.NSError
    public static let invalidated: Foundation.NSError
    public static let dataFailed: Foundation.NSError
    public static let dataCanceled: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Flags : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public static let audioBufferListAssure16ByteAlignment: CoreMedia.CMSampleBuffer.Flags
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias ArrayLiteralElement = CoreMedia.CMSampleBuffer.Flags
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Element = CoreMedia.CMSampleBuffer.Flags
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setDataBuffer(_ dataBuffer: CoreMedia.CMBlockBuffer) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var dataBuffer: CoreMedia.CMBlockBuffer? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var imageBuffer: CoreVideo.CVImageBuffer? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
  public var taggedBuffers: [CoreMedia.CMTaggedBuffer]? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setDataBuffer(fromAudioBufferList bufferList: Swift.UnsafePointer<CoreAudioTypes.AudioBufferList>, blockBufferMemoryAllocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMSampleBuffer.Flags = []) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func withAudioBufferList<R>(blockBufferMemoryAllocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMSampleBuffer.Flags = [], body: (CoreAudio.UnsafeMutableAudioBufferListPointer, CoreMedia.CMBlockBuffer) throws -> R) throws -> R
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func audioStreamPacketDescriptions() throws -> [CoreAudioTypes.AudioStreamPacketDescription]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func withUnsafeAudioStreamPacketDescriptions<R>(_ body: (Swift.UnsafeBufferPointer<CoreAudioTypes.AudioStreamPacketDescription>) throws -> R) throws -> R
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func copyPCMData(fromRange range: Swift.Range<Swift.Int>, into bufferList: Swift.UnsafeMutablePointer<CoreAudioTypes.AudioBufferList>) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public enum DataReadiness : Swift.Hashable, Swift.Sendable {
    case notReady
    case ready
    case failed(Darwin.OSStatus)
    public static func == (a: CoreMedia.CMSampleBuffer.DataReadiness, b: CoreMedia.CMSampleBuffer.DataReadiness) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var dataReadiness: CoreMedia.CMSampleBuffer.DataReadiness {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setDataReadiness(_ newValue: CoreMedia.CMSampleBuffer.DataReadiness) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func makeDataReady() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func trackDataReadiness(_ sampleBufferToTrack: CoreMedia.CMSampleBuffer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func invalidate() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setInvalidateHandler(_ body: @escaping (CoreMedia.CMSampleBuffer) throws -> Swift.Void) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var isValid: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var numSamples: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var duration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var presentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var decodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var outputDuration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var outputPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setOutputPresentationTimeStamp(_ pts: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var outputDecodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func sampleTimingInfos() throws -> [CoreMedia.CMSampleTimingInfo]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func outputSampleTimingInfos() throws -> [CoreMedia.CMSampleTimingInfo]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func sampleTimingInfo(at sampleIndex: CoreMedia.CMItemIndex) throws -> CoreMedia.CMSampleTimingInfo
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func sampleSizes() throws -> [Swift.Int]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func sampleSize(at sampleIndex: Swift.Int) -> Swift.Int
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var totalSampleSize: Swift.Int {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var formatDescription: CoreMedia.CMFormatDescription? {
    get
  }
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct PerSampleAttachmentsDictionary : Swift.Sequence {
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
    public struct Key : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
      public typealias _ObjectiveCType = CoreFoundation.CFString
      public typealias RawValue = CoreFoundation.CFString
      public var rawValue: CoreFoundation.CFString
      public init(rawValue: CoreFoundation.CFString)
      public static let notSync: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let partialSync: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hasRedundantCoding: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let isDependedOnByOthers: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let dependsOnOthers: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let earlierDisplayTimesAllowed: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let displayImmediately: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let doNotDisplay: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcTemporalLevelInfo: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcTemporalSubLayerAccess: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcStepwiseTemporalSubLayerAccess: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcSyncSampleNALUnitType: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let audioIndependentSampleDecoderRefreshCount: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
    }
    public typealias Element = (key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key, value: Any)
    public struct Iterator : Swift.IteratorProtocol {
      #if compiler(>=5.3) && $NonescapableTypes
      public mutating func next() -> (key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key, value: Any)?
      #endif
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
      public typealias Element = (key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key, value: Any)
    }
    public func makeIterator() -> CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Iterator
    #if compiler(>=5.3) && $NonescapableTypes
    public subscript(key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key) -> Any? {
      get
      set
    }
    #endif
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct SampleAttachmentsArray : Swift.Collection {
    public func index(after i: Swift.Int) -> Swift.Int
    public var startIndex: Swift.Int
    public var endIndex: Swift.Int
    public typealias Index = Swift.Int
    public subscript(sample: Swift.Int) -> CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary {
      get
      _modify
    }
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Element = CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Indices = Swift.DefaultIndices<CoreMedia.CMSampleBuffer.SampleAttachmentsArray>
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMSampleBuffer.SampleAttachmentsArray>
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias SubSequence = Swift.Slice<CoreMedia.CMSampleBuffer.SampleAttachmentsArray>
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var sampleAttachments: CoreMedia.CMSampleBuffer.SampleAttachmentsArray {
    get
    _modify
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct SingleSampleBuffers : Swift.Sequence {
    public typealias Element = CoreMedia.CMSampleBuffer
    public struct Iterator : Swift.IteratorProtocol {
      #if compiler(>=5.3) && $NonescapableTypes
      public mutating func next() -> CoreMedia.CMSampleBuffer?
      #endif
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
      public typealias Element = CoreMedia.CMSampleBuffer
    }
    public func makeIterator() -> CoreMedia.CMSampleBuffer.SingleSampleBuffers.Iterator
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func singleSampleBuffers() throws -> CoreMedia.CMSampleBuffer.SingleSampleBuffers
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct AttachmentKey : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
    public typealias RawValue = CoreFoundation.CFString
    public typealias _ObjectiveCType = CoreFoundation.CFString
    public var rawValue: CoreFoundation.CFString
    public init(rawValue: CoreFoundation.CFString)
    public static let resetDecoderBeforeDecoding: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let drainAfterDecoding: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let postNotificationWhenConsumed: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let resumeOutput: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let transitionID: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let trimDurationAtStart: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let trimDurationAtEnd: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let speedMultiplier: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let reverse: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let fillDiscontinuitiesWithSilence: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let emptyMedia: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let permanentEmptyMedia: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let displayEmptyMediaImmediately: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let endsPreviousSampleDuration: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let sampleReferenceURL: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let sampleReferenceByteOffset: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let gradualDecoderRefresh: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let droppedFrameReason: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let droppedFrameReasonInfo: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let stillImageLensStabilizationInfo: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let cameraIntrinsicMatrix: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let forceKeyFrame: CoreMedia.CMSampleBuffer.AttachmentKey
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMAttachmentBearerAttachments {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(key: CoreMedia.CMSampleBuffer.AttachmentKey) -> CoreMedia.CMAttachmentBearerAttachments.Value? {
    get
    set(newValue)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static let dataBecameReady: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static let dataFailed: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct NotificationKey : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
    public typealias RawValue = CoreFoundation.CFString
    public typealias _ObjectiveCType = CoreFoundation.CFString
    public var rawValue: CoreFoundation.CFString
    public init(rawValue: CoreFoundation.CFString)
    public static let status: CoreMedia.CMSampleBuffer.NotificationKey
  }
}
@available(*, unavailable)
extension CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary : Swift.Sendable {
}
@available(*, unavailable)
extension CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Iterator : Swift.Sendable {
}
@available(*, unavailable)
extension CoreMedia.CMSampleBuffer.SampleAttachmentsArray : Swift.Sendable {
}
@available(*, unavailable)
extension CoreMedia.CMSampleBuffer.SingleSampleBuffers : Swift.Sendable {
}
@available(*, unavailable)
extension CoreMedia.CMSampleBuffer.SingleSampleBuffers.Iterator : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMSampleTimingInfo : @unchecked Swift.Sendable, Swift.Equatable {
  @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, watchOS 12.0, visionOS 3.0)
  public static func == (lhs: CoreMedia.CMSampleTimingInfo, rhs: CoreMedia.CMSampleTimingInfo) -> Swift.Bool {
		lhs.duration == rhs.duration && lhs.decodeTimeStamp == rhs.decodeTimeStamp && lhs.presentationTimeStamp == rhs.presentationTimeStamp
	}
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension CoreMedia.__CMTagCategory : CoreMedia._CMFormatDescriptionFourCCConvertible {
  @available(iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, macOS 14.0, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
public class CMTag : Swift.Equatable, Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public typealias RawCategory = Darwin.FourCharCode
  public enum Value : Swift.Sendable, Swift.Equatable {
    case int64(Swift.Int64)
    case float64(Swift.Float64)
    case osType(Darwin.OSType)
    case flags(Swift.UInt64)
    public static func == (a: CoreMedia.CMTag.Value, b: CoreMedia.CMTag.Value) -> Swift.Bool
  }
  final public let rawCategory: CoreMedia.CMTag.RawCategory
  final public let rawTagValue: CoreMedia.CMTag.Value
  public init(rawCategory: CoreMedia.CMTag.RawCategory, rawTagValue: CoreMedia.CMTag.Value)
  #if compiler(>=5.3) && $NonescapableTypes
  public func value<T>(onlyIfMatching category: CoreMedia.CMTypedTag<T>.Category) -> T? where T : Swift.Sendable
  #endif
  public static func == (lhs: CoreMedia.CMTag, rhs: CoreMedia.CMTag) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
public class CMTypedTag<TypedValue> : CoreMedia.CMTag, @unchecked Swift.Sendable where TypedValue : Swift.Sendable {
  public struct Category : Swift.Sendable {
    public let rawCategory: CoreMedia.CMTypedTag<TypedValue>.RawCategory
    #if compiler(>=5.3) && $NonescapableTypes
    public func value(for tagValue: CoreMedia.CMTag.Value) -> TypedValue?
    #endif
    public func tagValue(for value: TypedValue) -> CoreMedia.CMTag.Value
    #if compiler(>=5.3) && $NonescapableTypes
    public init(rawCategory: CoreMedia.CMTypedTag<TypedValue>.RawCategory, valueForTagValue: @escaping @Sendable (CoreMedia.CMTag.Value) -> TypedValue?, tagValueForValue: @escaping @Sendable (TypedValue) -> CoreMedia.CMTag.Value)
    #endif
  }
  final public let category: CoreMedia.CMTypedTag<TypedValue>.Category
  public var value: TypedValue {
    get
  }
  public init(category: CoreMedia.CMTypedTag<TypedValue>.Category, value: TypedValue)
  @objc deinit
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension CoreMedia.CMTypedTag.Category {
  public static var mediaType: CoreMedia.CMTypedTag<CoreMedia.CMFormatDescription.MediaType>.Category {
    get
  }
  public static var mediaSubType: CoreMedia.CMTypedTag<CoreMedia.CMFormatDescription.MediaSubType>.Category {
    get
  }
  public static var trackID: CoreMedia.CMTypedTag<CoreMedia.CMPersistentTrackID>.Category {
    get
  }
  public static var channelID: CoreMedia.CMTypedTag<Swift.Int64>.Category {
    get
  }
  public static var videoLayerID: CoreMedia.CMTypedTag<Swift.Int64>.Category {
    get
  }
  public static var pixelFormat: CoreMedia.CMTypedTag<Darwin.OSType>.Category {
    get
  }
  public static var packingType: CoreMedia.CMTypedTag<CoreMedia.CMPackingType>.Category {
    get
  }
  public static var projectionType: CoreMedia.CMTypedTag<CoreMedia.CMProjectionType>.Category {
    get
  }
  public static var stereoView: CoreMedia.CMTypedTag<CoreMedia.CMStereoViewComponents>.Category {
    get
  }
  public static var stereoViewInterpretation: CoreMedia.CMTypedTag<CoreMedia.CMStereoViewInterpretationOptions>.Category {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension CoreMedia.CMTag {
  public static func mediaType(_ value: CoreMedia.CMFormatDescription.MediaType) -> CoreMedia.CMTypedTag<CoreMedia.CMFormatDescription.MediaType>
  public static func mediaSubType(_ value: CoreMedia.CMFormatDescription.MediaSubType) -> CoreMedia.CMTypedTag<CoreMedia.CMFormatDescription.MediaSubType>
  public static func trackID(_ value: CoreMedia.CMPersistentTrackID) -> CoreMedia.CMTypedTag<CoreMedia.CMPersistentTrackID>
  public static func channelID(_ value: Swift.Int64) -> CoreMedia.CMTypedTag<Swift.Int64>
  public static func videoLayerID(_ value: Swift.Int64) -> CoreMedia.CMTypedTag<Swift.Int64>
  public static func pixelFormat(_ value: Darwin.OSType) -> CoreMedia.CMTypedTag<Darwin.OSType>
  public static func packingType(_ value: CoreMedia.CMPackingType) -> CoreMedia.CMTypedTag<CoreMedia.CMPackingType>
  public static func projectionType(_ value: CoreMedia.CMProjectionType) -> CoreMedia.CMTypedTag<CoreMedia.CMProjectionType>
  public static func stereoView(_ value: CoreMedia.CMStereoViewComponents) -> CoreMedia.CMTypedTag<CoreMedia.CMStereoViewComponents>
  public static func stereoViewInterpretation(_ value: CoreMedia.CMStereoViewInterpretationOptions) -> CoreMedia.CMTypedTag<CoreMedia.CMStereoViewInterpretationOptions>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension Swift.Sequence where Self.Element : CoreMedia.CMTag {
  public func filter<T>(matchingCategory category: CoreMedia.CMTypedTag<T>.Category) -> [CoreMedia.CMTypedTag<T>] where T : Swift.Sendable
  #if compiler(>=5.3) && $NonescapableTypes
  public func firstValue<T>(matchingCategory category: CoreMedia.CMTypedTag<T>.Category) -> T? where T : Swift.Sendable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func first<T>(matchingCategory category: CoreMedia.CMTypedTag<T>.Category) -> CoreMedia.CMTypedTag<T>? where T : Swift.Sendable
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.Array : CoreMedia.CMSampleBuffer.Content, CoreMedia.CMSampleBuffer.ContentWithFormatDescription where Element == CoreMedia.CMTaggedDynamicBuffer {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMReadySampleBuffer where Content == [CoreMedia.CMTaggedDynamicBuffer] {
  #if compiler(>=5.3) && $SendingArgsAndResults
  public init(unsafeWithTaggedBuffers unsafeBuffer: sending CoreMedia.CMSampleBuffer)
  #else
  public init(unsafeWithTaggedBuffers unsafeBuffer: __owned CoreMedia.CMSampleBuffer)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ other: CoreMedia.CMReadySampleBuffer<CoreMedia.CMSampleBuffer.DynamicContent>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(taggedBuffers content: Content, formatDescription: CoreMedia.CMTaggedBufferGroupFormatDescription? = nil, presentationTimeStamp: CoreMedia.CMTime, duration: CoreMedia.CMTime = .invalid)
  #endif
  public var content: Swift.Array<CoreMedia.CMTaggedDynamicBuffer> {
    get
    set
  }
  public var presentationTimeStamp: CoreMedia.CMTime {
    get
    set
  }
  public var duration: CoreMedia.CMTime {
    get
    set
  }
  public var sampleAttachments: CoreMedia.CMSampleBuffer.SampleAttachments {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBufferQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Handlers : @unchecked Swift.Sendable {
    public let getDecodeTimeStamp: CoreMedia.CMBufferGetTimeHandler?
    public let getPresentationTimeStamp: CoreMedia.CMBufferGetTimeHandler?
    public let getDuration: CoreMedia.CMBufferGetTimeHandler
    public let isDataReady: CoreMedia.CMBufferGetBooleanHandler?
    public let compare: CoreMedia.CMBufferCompareHandler?
    public let dataBecameReadyNotification: Swift.String?
    public let getSize: CoreMedia.CMBufferGetSizeHandler?
    public struct Builder : @unchecked Swift.Sendable {
      public var dataBecameReadyNotification: Swift.String?
      public mutating func getDecodeTimeStamp(_ body: @escaping CoreMedia.CMBufferGetTimeHandler)
      public mutating func getPresentationTimeStamp(_ body: @escaping CoreMedia.CMBufferGetTimeHandler)
      public mutating func getDuration(_ body: @escaping CoreMedia.CMBufferGetTimeHandler)
      public mutating func isDataReady(_ body: @escaping CoreMedia.CMBufferGetBooleanHandler)
      public mutating func compare(_ body: @escaping CoreMedia.CMBufferCompareHandler)
      public mutating func getSize(_ body: @escaping CoreMedia.CMBufferGetSizeHandler)
    }
    public init(withHandlers body: (inout CoreMedia.CMBufferQueue.Handlers.Builder) -> Swift.Void)
    public func withHandlers(_ body: (inout CoreMedia.CMBufferQueue.Handlers.Builder) -> Swift.Void) -> CoreMedia.CMBufferQueue.Handlers
    public static let unsortedSampleBuffers: CoreMedia.CMBufferQueue.Handlers
    public static let outputPTSSortedSampleBuffers: CoreMedia.CMBufferQueue.Handlers
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMBufferQueueInitTrampoline : CoreMedia._CMInitTrampoline where Self.T == CoreMedia.CMBufferQueue {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMBufferQueueInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(capacity: CoreMedia.CMItemCount, handlers: CoreMedia.CMBufferQueue.Handlers) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBufferQueue : CoreMedia._CMBufferQueueInitTrampoline {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias T = CoreMedia.CMBufferQueue
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBufferQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let allocationFailed: Foundation.NSError
    public static let requiredParameterMissing: Foundation.NSError
    public static let invalidCMBufferCallbacksStruct: Foundation.NSError
    public static let enqueueAfterEndOfData: Foundation.NSError
    public static let queueIsFull: Foundation.NSError
    public static let badTriggerDuration: Foundation.NSError
    public static let cannotModifyQueueFromTriggerCallback: Foundation.NSError
    public static let invalidTriggerCondition: Foundation.NSError
    public static let invalidTriggerToken: Foundation.NSError
    public static let invalidBuffer: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBufferQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public typealias TriggerToken = CoreMedia.CMBufferQueueTriggerToken
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public enum TriggerCondition : Swift.Sendable {
    case whenDurationBecomesLessThan(CoreMedia.CMTime)
    case whenDurationBecomesLessThanOrEqualTo(CoreMedia.CMTime)
    case whenDurationBecomesGreaterThan(CoreMedia.CMTime)
    case whenDurationBecomesGreaterThanOrEqualTo(CoreMedia.CMTime)
    case whenMinPresentationTimeStampChanges
    case whenMaxPresentationTimeStampChanges
    case whenDataBecomesReady
    case whenEndOfDataReached
    case whenReset
    case whenBufferCountBecomesLessThan(CoreMedia.CMItemCount)
    case whenBufferCountBecomesGreaterThan(CoreMedia.CMItemCount)
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func enqueue(_ buffer: CoreMedia.CMBuffer) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func dequeue() -> CoreMedia.CMBuffer?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func dequeueIfDataReady() -> CoreMedia.CMBuffer?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var head: CoreMedia.CMBuffer? {
    get
  }
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var isEmpty: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func markEndOfData() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var containsEndOfData: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var isAtEndOfData: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func reset() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func reset(_ body: (CoreMedia.CMBuffer) throws -> ()) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var bufferCount: CoreMedia.CMItemCount {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var duration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var minDecodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var firstDecodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var minPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var firstPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var maxPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var endPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var totalSize: Swift.Int {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func installTrigger(condition: CoreMedia.CMBufferQueue.TriggerCondition, _ body: CoreMedia.CMBufferQueueTriggerHandler? = nil) throws -> CoreMedia.CMBufferQueue.TriggerToken
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func removeTrigger(_ triggerToken: CoreMedia.CMBufferQueue.TriggerToken) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func testTrigger(_ triggerToken: CoreMedia.CMBufferQueue.TriggerToken) -> Swift.Bool
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Buffers : Swift.Sequence {
    public typealias Element = AnyObject
    public struct Iterator : Swift.IteratorProtocol {
      #if compiler(>=5.3) && $NonescapableTypes
      public mutating func next() -> CoreMedia.CMBuffer?
      #endif
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
      public typealias Element = CoreMedia.CMBuffer
    }
    public func makeIterator() -> CoreMedia.CMBufferQueue.Buffers.Iterator
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var buffers: CoreMedia.CMBufferQueue.Buffers {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func setValidationHandler(_ body: @escaping (CoreMedia.CMBufferQueue, CoreMedia.CMBuffer) throws -> Swift.Void)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public class var typeID: CoreFoundation.CFTypeID {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Extensions : @unchecked Swift.Sendable {
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
    public struct Key : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
      public typealias RawValue = CoreFoundation.CFString
      public typealias _ObjectiveCType = CoreFoundation.CFString
      public var rawValue: CoreFoundation.CFString
      public init(rawValue: CoreFoundation.CFString)
      public static let originalCompressionSettings: CoreMedia.CMFormatDescription.Extensions.Key
      public static let sampleDescriptionExtensionAtoms: CoreMedia.CMFormatDescription.Extensions.Key
      public static let verbatimSampleDescription: CoreMedia.CMFormatDescription.Extensions.Key
      public static let verbatimISOSampleEntry: CoreMedia.CMFormatDescription.Extensions.Key
      public static let formatName: CoreMedia.CMFormatDescription.Extensions.Key
      public static let depth: CoreMedia.CMFormatDescription.Extensions.Key
      public static let cleanAperture: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fieldCount: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fieldDetail: CoreMedia.CMFormatDescription.Extensions.Key
      public static let pixelAspectRatio: CoreMedia.CMFormatDescription.Extensions.Key
      public static let colorPrimaries: CoreMedia.CMFormatDescription.Extensions.Key
      public static let transferFunction: CoreMedia.CMFormatDescription.Extensions.Key
      public static let gammaLevel: CoreMedia.CMFormatDescription.Extensions.Key
      public static let yCbCrMatrix: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fullRangeVideo: CoreMedia.CMFormatDescription.Extensions.Key
      public static let iccProfile: CoreMedia.CMFormatDescription.Extensions.Key
      public static let bytesPerRow: CoreMedia.CMFormatDescription.Extensions.Key
      public static let chromaLocationTopField: CoreMedia.CMFormatDescription.Extensions.Key
      public static let chromaLocationBottomField: CoreMedia.CMFormatDescription.Extensions.Key
      public static let conformsToMPEG2VideoProfile: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, watchOS 12.0, visionOS 3.0)
      public static var protectedContentOriginalFormat: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_ProtectedContentOriginalFormat) }
      }
      public static let temporalQuality: CoreMedia.CMFormatDescription.Extensions.Key
      public static let spatialQuality: CoreMedia.CMFormatDescription.Extensions.Key
      public static let version: CoreMedia.CMFormatDescription.Extensions.Key
      public static let revisionLevel: CoreMedia.CMFormatDescription.Extensions.Key
      public static let vendor: CoreMedia.CMFormatDescription.Extensions.Key
      public static let masteringDisplayColorVolume: CoreMedia.CMFormatDescription.Extensions.Key
      public static let contentLightLevelInfo: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, watchOS 12.0, visionOS 3.0)
      public static var contentColorVolume: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_ContentColorVolume) }
      }
      public static let alternativeTransferCharacteristics: CoreMedia.CMFormatDescription.Extensions.Key
      public static let auxiliaryTypeInfo: CoreMedia.CMFormatDescription.Extensions.Key
      public static let alphaChannelMode: CoreMedia.CMFormatDescription.Extensions.Key
      public static let containsAlphaChannel: CoreMedia.CMFormatDescription.Extensions.Key
      public static let displayFlags: CoreMedia.CMFormatDescription.Extensions.Key
      public static let backgroundColor: CoreMedia.CMFormatDescription.Extensions.Key
      public static let defaultTextBox: CoreMedia.CMFormatDescription.Extensions.Key
      public static let defaultStyle: CoreMedia.CMFormatDescription.Extensions.Key
      public static let horizontalJustification: CoreMedia.CMFormatDescription.Extensions.Key
      public static let verticalJustification: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fontTable: CoreMedia.CMFormatDescription.Extensions.Key
      public static let textJustification: CoreMedia.CMFormatDescription.Extensions.Key
      public static let defaultFontName: CoreMedia.CMFormatDescription.Extensions.Key
      public static let sourceReferenceName: CoreMedia.CMFormatDescription.Extensions.Key
      public static let metadataKeyTable: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
      public static let ambientViewingEnvironment: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
      public static let bitsPerComponent: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, watchOS 12.0, visionOS 3.0)
      public static var horizontalFieldOfView: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_HorizontalFieldOfView) }
      }
      @available(macOS 14.2, iOS 17.2, tvOS 17.2, watchOS 10.2, visionOS 1.1, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, watchOS 12.0, visionOS 3.0)
      public static var logTransferFunction: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_LogTransferFunction) }
      }
      @available(macOS 14.0, iOS 17.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, visionOS 3.0)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static var heroEye: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_HeroEye) }
      }
      @available(macOS 14.0, iOS 17.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, visionOS 3.0)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static var stereoCameraBaseline: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_StereoCameraBaseline) }
      }
      @available(macOS 14.0, iOS 17.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, visionOS 3.0)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static var horizontalDisparityAdjustment: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_HorizontalDisparityAdjustment) }
      }
      @available(macOS 14.0, iOS 17.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, visionOS 3.0)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static var hasLeftStereoEyeView: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_HasLeftStereoEyeView) }
      }
      @available(macOS 14.0, iOS 17.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, visionOS 3.0)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static var hasRightStereoEyeView: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_HasRightStereoEyeView) }
      }
      @available(macOS 14.0, iOS 17.0, visionOS 1.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, visionOS 3.0)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static var hasAdditionalViews: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_HasAdditionalViews) }
      }
      @available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static let convertedFromExternalSphericalTags: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
      @backDeployed(before: macOS 16.0, iOS 19.0, visionOS 3.0)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static var projectionKind: CoreMedia.CMFormatDescription.Extensions.Key {
        get { Key(rawValue: kCMFormatDescriptionExtension_ProjectionKind) }
      }
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public static let viewPackingKind: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public static let cameraCalibrationDataLensCollection: CoreMedia.CMFormatDescription.Extensions.Key
    }
    public struct Value : @unchecked Swift.Sendable {
      public var propertyListRepresentation: CoreFoundation.CFPropertyList
      public init(_ plist: CoreFoundation.CFPropertyList)
      public static func number<T>(_ value: T) -> CoreMedia.CMFormatDescription.Extensions.Value where T : Swift.Numeric
      public static func string(_ value: Swift.String) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func string(_ value: CoreFoundation.CFString) -> CoreMedia.CMFormatDescription.Extensions.Value
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
      public static func data(_ value: CoreFoundation.CFData) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func cleanAperture<Width, Height, Horizontal, Vertical>(width: Width, height: Height, horizontalOffet: Horizontal, verticalOffset: Vertical) -> CoreMedia.CMFormatDescription.Extensions.Value where Width : Swift.Numeric, Height : Swift.Numeric, Horizontal : Swift.Numeric, Vertical : Swift.Numeric
      public static func cleanAperture(width: (numerator: Swift.Int, denominator: Swift.Int), height: (numerator: Swift.Int, denominator: Swift.Int), horizontalOffet: (numerator: Swift.Int, denominator: Swift.Int), verticalOffset: (numerator: Swift.Int, denominator: Swift.Int)) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct FieldDetail : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let temporalTopFirst: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
        public static let temporalBottomFirst: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
        public static let spatialFirstLineEarly: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
        public static let spatialFirstLineLate: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
      }
      public static func fieldDetail(_ fieldDetail: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func pixelAspectRatio<Horizontal, Vertical>(horizontalSpacing: Horizontal, verticalSpacing: Vertical) -> CoreMedia.CMFormatDescription.Extensions.Value where Horizontal : Swift.Numeric, Vertical : Swift.Numeric
      public struct ColorPrimaries : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let itu_R_709_2: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let ebu_3213: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let smpte_C: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let dci_P3: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let p3_D65: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let itu_R_2020: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let p22: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
      }
      public static func colorPrimaries(_ colorPrimaries: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct TransferFunction : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let itu_R_709_2: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let smpte_240M_1995: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let useGamma: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let itu_R_2020: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let smpte_ST_428_1: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let smpte_ST_2084_PQ: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let itu_R_2100_HLG: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let linear: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let sRGB: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
      }
      public static func transferFunction(_ transferFunction: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct YCbCrMatrix : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let itu_R_709_2: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
        public static let itu_R_601_4: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
        public static let smpted_240M_1995: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
        public static let itu_R_2020: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
      }
      public static func yCbCrMatrix(_ yCbCrMatrix: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct ChromaLocation : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let left: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let center: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let topLeft: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let top: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let bottomLeft: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let bottom: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let dv420: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
      }
      public static func chromaLocation(_ chromaLocation: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct MPEG2VideoProfile : CoreMedia._CMFormatDescriptionFourCCConvertible, @unchecked Swift.Sendable {
        public var rawValue: Darwin.FourCharCode
        @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
        public init(rawValue: Darwin.FourCharCode)
        @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
        public init(rawValue: Swift.Int32)
        public static let hdv_720p30: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080i60: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080i50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p24: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p25: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080p24: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080p25: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080p30: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p60: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080i60_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080i50_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080p24_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080p25_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080p30_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p24_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p25_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p30_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p50_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p60_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080i60_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080i50_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080p24_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080p25_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080p30_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p50_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p60_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080i60_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080i50_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080p24_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080p25_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080p30_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_540p: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_540p: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p24_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p25_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p30_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xf: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
        public typealias RawValue = Swift.UInt32
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
        public typealias _ObjectiveCType = Foundation.NSNumber
      }
      public static func mpeg2VideoProfile(_ mpeg2VideoProfile: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct Vendor : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public var rawValue: CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
        public init(rawValue: CoreFoundation.CFString)
        public static let apple: CoreMedia.CMFormatDescription.Extensions.Value.Vendor
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
        public typealias RawValue = CoreFoundation.CFString
      }
      public static func vendor(_ vendor: CoreMedia.CMFormatDescription.Extensions.Value.Vendor) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func vendor(_ fourCC: Swift.String) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct AlphaChannelMode : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let straightAlpha: CoreMedia.CMFormatDescription.Extensions.Value.AlphaChannelMode
        public static let premultipliedAlpha: CoreMedia.CMFormatDescription.Extensions.Value.AlphaChannelMode
      }
      public static func alphaChannelMode(_ alphaChannelMode: CoreMedia.CMFormatDescription.Extensions.Value.AlphaChannelMode) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func qtTextColor(red: CoreFoundation.CGFloat, green: CoreFoundation.CGFloat, blue: CoreFoundation.CGFloat, alpha: CoreFoundation.CGFloat) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func mobile3GPPTextColor(red: CoreFoundation.CGFloat, green: CoreFoundation.CGFloat, blue: CoreFoundation.CGFloat, alpha: CoreFoundation.CGFloat) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func fontTable(_ fontTable: [Swift.Int : Swift.String]) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct FontFace : Swift.OptionSet, CoreMedia._CMObjectiveCBridgeableWithRawValue, Swift.Sendable {
        public typealias RawValue = Swift.UInt8
        public typealias _ObjectiveCType = Foundation.NSNumber
        public var rawValue: Swift.UInt8
        public init(rawValue: Swift.UInt8)
        public static let bold: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public static let italic: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public static let underline: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public static let all: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
        public typealias ArrayLiteralElement = CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
        public typealias Element = CoreMedia.CMFormatDescription.Extensions.Value.FontFace
      }
      #if compiler(>=5.3) && $NonescapableTypes
      public static func qtTextDefaultStyle(startChar: Swift.Int, height: Swift.Int, ascent: Swift.Int, localFontID: Swift.Int, fontFace: CoreMedia.CMFormatDescription.Extensions.Value.FontFace, fontSize: Swift.Int, foregroundColor: CoreMedia.CMFormatDescription.Extensions.Value, defaultFontName: Swift.String?) -> CoreMedia.CMFormatDescription.Extensions.Value
      #endif
      public static func mobile3GPPTextDefaultStyle(startChar: Swift.Int, endChar: Swift.Int, localFontID: Swift.Int, fontFace: CoreMedia.CMFormatDescription.Extensions.Value.FontFace, fontSize: Swift.Int, foregroundColor: CoreMedia.CMFormatDescription.Extensions.Value) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func textRect(top: Swift.Int, left: Swift.Int, bottom: Swift.Int, right: Swift.Int) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct TextDisplayFlags : CoreMedia._CMObjectiveCBridgeableWithRawValue, Swift.Sendable {
        public typealias RawValue = CoreMedia.CMTextDisplayFlags
        public typealias _ObjectiveCType = Foundation.NSNumber
        public var rawValue: CoreMedia.CMTextDisplayFlags
        public init(rawValue: CoreMedia.CMTextDisplayFlags)
        public static let scrollIn: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollOut: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirectionMask: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_bottomToTop: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_rightToLeft: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_topToBottom: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_leftToRight: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let continuousKaraoke: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let writeTextVertically: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let fillTextRegion: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let obeySubtitleFormatting: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let forcedSubtitlesPresent: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let allSubtitlesForced: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public var scrollDirection: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags {
          get
        }
      }
      public static func textDisplayFlags(_ textDisplayFlags: Swift.Set<CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags>) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct TextJustification : CoreMedia._CMObjectiveCBridgeableWithRawValue, Swift.Sendable {
        public typealias RawValue = Swift.Int8
        public typealias _ObjectiveCType = Foundation.NSNumber
        public var rawValue: Swift.Int8
        public init(rawValue: Swift.Int8)
        public static let left: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let top: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let centered: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let bottom: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let right: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
      }
      public static func textJustification(_ textJustification: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func sourceReferenceName(value: Swift.String, langCode: Swift.Int) -> CoreMedia.CMFormatDescription.Extensions.Value
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      @frozen public struct LogTransferFunction : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let appleLog: CoreMedia.CMFormatDescription.Extensions.Value.LogTransferFunction
      }
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public static func logTransferFunction(_ logTransferFunction: CoreMedia.CMFormatDescription.Extensions.Value.LogTransferFunction) -> CoreMedia.CMFormatDescription.Extensions.Value
      @available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public struct HeroEye : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let left: CoreMedia.CMFormatDescription.Extensions.Value.HeroEye
        public static let right: CoreMedia.CMFormatDescription.Extensions.Value.HeroEye
      }
      @available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public static func heroEye(_ heroEye: CoreMedia.CMFormatDescription.Extensions.Value.HeroEye) -> CoreMedia.CMFormatDescription.Extensions.Value
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public struct ContentColorVolume : Swift.Sendable, Swift.Hashable, Swift.RawRepresentable {
        @frozen public struct ColorVolume : Swift.Sendable, Swift.Hashable {
          public var green: Swift.Int32
          public var blue: Swift.Int32
          public var red: Swift.Int32
          public init(green: Swift.Int32, blue: Swift.Int32, red: Swift.Int32)
          public static func == (a: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorVolume, b: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorVolume) -> Swift.Bool
          public func hash(into hasher: inout Swift.Hasher)
          public var hashValue: Swift.Int {
            get
          }
        }
        @frozen public struct ColorPrimaries : Swift.Sendable, Swift.Hashable {
          public var x: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorVolume
          public var y: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorVolume
          public init(x: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorVolume, y: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorVolume)
          public static func == (a: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorPrimaries, b: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorPrimaries) -> Swift.Bool
          public func hash(into hasher: inout Swift.Hasher)
          public var hashValue: Swift.Int {
            get
          }
        }
        public var colorPrimaries: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorPrimaries?
        public var minimumLuminance: Swift.UInt32?
        public var maximumLuminance: Swift.UInt32?
        public var averageLuminance: Swift.UInt32?
        #if compiler(>=5.3) && $NonescapableTypes
        public init(colorPrimaries: CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorPrimaries? = nil, minimumLuminance: Swift.UInt32? = nil, maximumLuminance: Swift.UInt32? = nil, averageLuminance: Swift.UInt32? = nil)
        #endif
        public var rawValue: CoreMedia.CMFormatDescription.Extensions.Value {
          get
        }
        #if compiler(>=5.3) && $NonescapableTypes
        public init?(rawValue: CoreMedia.CMFormatDescription.Extensions.Value)
        #endif
        @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
        public typealias RawValue = CoreMedia.CMFormatDescription.Extensions.Value
      }
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public struct ProjectionKind : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let rectilinear: CoreMedia.CMFormatDescription.Extensions.Value.ProjectionKind
        public static let equirectangular: CoreMedia.CMFormatDescription.Extensions.Value.ProjectionKind
        public static let halfEquirectangular: CoreMedia.CMFormatDescription.Extensions.Value.ProjectionKind
        public static let parametricImmersive: CoreMedia.CMFormatDescription.Extensions.Value.ProjectionKind
        public static let appleImmersiveVideo: CoreMedia.CMFormatDescription.Extensions.Value.ProjectionKind
      }
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public static func projectionKind(_ projectionKind: CoreMedia.CMFormatDescription.Extensions.Value.ProjectionKind) -> CoreMedia.CMFormatDescription.Extensions.Value
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public struct ViewPackingKind : CoreMedia._CMObjectiveCBridgeableWithRawValue, @unchecked Swift.Sendable {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let sideBySide: CoreMedia.CMFormatDescription.Extensions.Value.ViewPackingKind
        public static let overUnder: CoreMedia.CMFormatDescription.Extensions.Value.ViewPackingKind
      }
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public static func viewPackingKind(_ viewPackingKind: CoreMedia.CMFormatDescription.Extensions.Value.ViewPackingKind) -> CoreMedia.CMFormatDescription.Extensions.Value
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public enum CameraCalibrationDataLensCollection : Swift.Sendable, Swift.RawRepresentable {
        public enum AlgorithmKind : Swift.Sendable, Swift.RawRepresentable {
          case parametric
          public var rawValue: CoreFoundation.CFString {
            get
          }
          #if compiler(>=5.3) && $NonescapableTypes
          public init?(rawValue: CoreFoundation.CFString)
          #endif
          @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
          public typealias RawValue = CoreFoundation.CFString
        }
        public enum LensRole : Swift.Sendable, Swift.RawRepresentable {
          case mono
          case left
          case right
          public var rawValue: CoreFoundation.CFString {
            get
          }
          #if compiler(>=5.3) && $NonescapableTypes
          public init?(rawValue: CoreFoundation.CFString)
          #endif
          @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
          public typealias RawValue = CoreFoundation.CFString
        }
        public enum LensDomain : Swift.Sendable, Swift.RawRepresentable {
          case color
          public var rawValue: CoreFoundation.CFString {
            get
          }
          #if compiler(>=5.3) && $NonescapableTypes
          public init?(rawValue: CoreFoundation.CFString)
          #endif
          @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
          public typealias RawValue = CoreFoundation.CFString
        }
        public enum ExtrinsicOriginSource : Swift.Sendable, Swift.RawRepresentable {
          case stereoCameraSystemBaseline
          public var rawValue: CoreFoundation.CFString {
            get
          }
          #if compiler(>=5.3) && $NonescapableTypes
          public init?(rawValue: CoreFoundation.CFString)
          #endif
          @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
          public typealias RawValue = CoreFoundation.CFString
        }
        public struct Calibration : Swift.Sendable, Swift.RawRepresentable {
          public var algorithmKind: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.AlgorithmKind
          public var identifier: Swift.Int32
          public var domain: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensDomain
          public var role: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensRole
          public var distortionCoefficients: Swift.SIMD4<Swift.Float>
          public var xFrameAdjustmentsPolynomial: Swift.SIMD3<Swift.Float>
          public var yFrameAdjustmentsPolynomial: Swift.SIMD3<Swift.Float>
          public var radialAngleLimit: Swift.Float
          public var intrinsicMatrix: simd.simd_float3x3
          public var intrinsicMatrixProjectionOffset: Swift.Float
          public var intrinsicMatrixReferenceDimensions: CoreFoundation.CGSize
          public var extrinsicOriginSource: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.ExtrinsicOriginSource
          public var extrinsicOrientationQuaternion: Swift.SIMD3<Swift.Float>
          public init(algorithmKind: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.AlgorithmKind, identifier: Swift.Int32, domain: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensDomain, role: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensRole, distortionCoefficients: Swift.SIMD4<Swift.Float>, xFrameAdjustmentsPolynomial: Swift.SIMD3<Swift.Float>, yFrameAdjustmentsPolynomial: Swift.SIMD3<Swift.Float>, radialAngleLimit: Swift.Float, intrinsicMatrix: simd.simd_float3x3, intrinsicMatrixProjectionOffset: Swift.Float, intrinsicMatrixReferenceDimensions: CoreFoundation.CGSize, extrinsicOriginSource: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.ExtrinsicOriginSource, extrinsicOrientationQuaternion: Swift.SIMD3<Swift.Float>)
          public var rawValue: CoreFoundation.CFDictionary {
            get
          }
          #if compiler(>=5.3) && $NonescapableTypes
          public init?(rawValue: CoreFoundation.CFDictionary)
          #endif
          @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
          public typealias RawValue = CoreFoundation.CFDictionary
        }
        case mono(CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.Calibration)
        case stereo(left: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.Calibration, right: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.Calibration)
        public var rawValue: CoreFoundation.CFArray {
          get
        }
        #if compiler(>=5.3) && $NonescapableTypes
        public init?(rawValue: CoreFoundation.CFArray)
        #endif
        @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
        public typealias RawValue = CoreFoundation.CFArray
      }
      @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
      public static func cameraCalibrationDataLensCollection(_ value: CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection) -> CoreMedia.CMFormatDescription.Extensions.Value
    }
    public init()
    #if compiler(>=5.3) && $NonescapableTypes
    public init(base: [CoreFoundation.CFString : CoreFoundation.CFPropertyList]?)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public subscript(key: CoreMedia.CMFormatDescription.Extensions.Key) -> CoreMedia.CMFormatDescription.Extensions.Value? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public subscript(key: CoreFoundation.CFString) -> CoreFoundation.CFPropertyList? {
      get
      set
    }
    #endif
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value : Swift.Hashable {
  public static func == (lhs: CoreMedia.CMFormatDescription.Extensions.Value, rhs: CoreMedia.CMFormatDescription.Extensions.Value) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.Extensions : Swift.Collection {
  public struct Index : @unchecked Swift.Sendable {
  }
  public var startIndex: CoreMedia.CMFormatDescription.Extensions.Index {
    get
  }
  public var endIndex: CoreMedia.CMFormatDescription.Extensions.Index {
    get
  }
  public subscript(position: CoreMedia.CMFormatDescription.Extensions.Index) -> (key: CoreFoundation.CFString, value: CoreFoundation.CFPropertyList) {
    get
  }
  public func index(after i: CoreMedia.CMFormatDescription.Extensions.Index) -> CoreMedia.CMFormatDescription.Extensions.Index
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias Element = (key: CoreFoundation.CFString, value: CoreFoundation.CFPropertyList)
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias Indices = Swift.DefaultIndices<CoreMedia.CMFormatDescription.Extensions>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMFormatDescription.Extensions>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias SubSequence = Swift.Slice<CoreMedia.CMFormatDescription.Extensions>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Index : Swift.Equatable {
  public static func == (lhs: CoreMedia.CMFormatDescription.Extensions.Index, rhs: CoreMedia.CMFormatDescription.Extensions.Index) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Index : Swift.Comparable {
  public static func < (lhs: CoreMedia.CMFormatDescription.Extensions.Index, rhs: CoreMedia.CMFormatDescription.Extensions.Index) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.Extensions : Swift.Equatable {
  public static func == (lhs: CoreMedia.CMFormatDescription.Extensions, rhs: CoreMedia.CMFormatDescription.Extensions) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.Extensions : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMFormatDescriptionInitTrampoline : CoreMedia._CMInitTrampoline where Self.T == CoreMedia.CMFormatDescription {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(mediaType: CoreMedia.CMFormatDescription.MediaType, mediaSubType: CoreMedia.CMFormatDescription.MediaSubType, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(audioStreamBasicDescription: CoreAudioTypes.AudioStreamBasicDescription, layoutSize: Swift.Int, layout: Swift.UnsafePointer<CoreAudioTypes.AudioChannelLayout>?, magicCookie: Foundation.Data?, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(audioStreamBasicDescription: CoreAudioTypes.AudioStreamBasicDescription, layout: CoreAudio.ManagedAudioChannelLayout? = nil, magicCookie: Foundation.Data? = nil, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(audioFormatDescriptionArray: [CoreMedia.CMAudioFormatDescription]) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(videoCodecType: CoreMedia.CMFormatDescription.MediaSubType, width: Swift.Int, height: Swift.Int, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(imageBuffer: CoreVideo.CVImageBuffer) throws
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
  public init(pixelBuffer: CoreVideo.CVReadOnlyPixelBuffer)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
  public init(pixelBuffer: borrowing CoreVideo.CVMutablePixelBuffer)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(h264ParameterSets: [Foundation.Data], nalUnitHeaderLength: Swift.Int = 4) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(hevcParameterSets: [Foundation.Data], nalUnitHeaderLength: Swift.Int = 4, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  #endif
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
  public init(taggedBuffers: [CoreMedia.CMTaggedBuffer])
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
  public init(taggedBuffers: [CoreMedia.CMTaggedBuffer], extensions: CoreMedia.CMFormatDescription.Extensions?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
  public init(taggedBuffers: [CoreMedia.CMTaggedDynamicBuffer], extensions: CoreMedia.CMFormatDescription.Extensions? = nil)
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(muxedStreamType: CoreMedia.CMFormatDescription.MediaSubType, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(timeCodeFormatType: CoreMedia.CMFormatDescription.MediaSubType, frameDuration: CoreMedia.CMTime, frameQuanta: Swift.Int, flags: CoreMedia.CMTimeCodeFormatDescription.TimeCode.Flag, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(metadataFormatType: CoreMedia.CMFormatDescription.MediaSubType) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(boxedMetadataKeys: [[Swift.String : CoreFoundation.CFPropertyList]]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(boxedMetadataSpecifications: [[Swift.String : CoreFoundation.CFPropertyList]]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(sourceMetadata: CoreMedia.CMMetadataFormatDescription, specifications: [[Swift.String : CoreFoundation.CFPropertyList]]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(sourceMetadata: CoreMedia.CMMetadataFormatDescription, otherSourceDescription: CoreMedia.CMMetadataFormatDescription) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription : CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias T = CoreMedia.CMFormatDescription
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let valueNotAvailable: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMFormatDescriptionFourCCConvertible : CoreMedia._CMObjectiveCBridgeableWithRawValue, Swift.CustomStringConvertible where Self.RawValue == Swift.UInt32, Self._ObjectiveCType == Foundation.NSNumber {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMFormatDescriptionFourCCConvertible {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var description: Swift.String {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(string: Swift.String)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct MediaType : CoreMedia._CMFormatDescriptionFourCCConvertible, Swift.Sendable {
    public var rawValue: CoreMedia.CMMediaType
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
    public init(rawValue: CoreMedia.CMMediaType)
    public static let video: CoreMedia.CMFormatDescription.MediaType
    public static let audio: CoreMedia.CMFormatDescription.MediaType
    public static let muxed: CoreMedia.CMFormatDescription.MediaType
    public static let text: CoreMedia.CMFormatDescription.MediaType
    public static let closedCaption: CoreMedia.CMFormatDescription.MediaType
    public static let subtitle: CoreMedia.CMFormatDescription.MediaType
    public static let timeCode: CoreMedia.CMFormatDescription.MediaType
    public static let metadata: CoreMedia.CMFormatDescription.MediaType
    public static let taggedBufferGroup: CoreMedia.CMFormatDescription.MediaType
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias RawValue = Swift.UInt32
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias _ObjectiveCType = Foundation.NSNumber
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct MediaSubType : CoreMedia._CMFormatDescriptionFourCCConvertible, Swift.Sendable {
    public var rawValue: Darwin.FourCharCode
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
    public init(rawValue: Darwin.FourCharCode)
    public static let linearPCM: CoreMedia.CMFormatDescription.MediaSubType
    public static let ac3: CoreMedia.CMFormatDescription.MediaSubType
    public static let iec60958AC3: CoreMedia.CMFormatDescription.MediaSubType
    public static let appleIMA4: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4CELP: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4HVXC: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4TwinVQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let mace3: CoreMedia.CMFormatDescription.MediaSubType
    public static let mace6: CoreMedia.CMFormatDescription.MediaSubType
    public static let uLaw: CoreMedia.CMFormatDescription.MediaSubType
    public static let aLaw: CoreMedia.CMFormatDescription.MediaSubType
    public static let qDesign: CoreMedia.CMFormatDescription.MediaSubType
    public static let qDesign2: CoreMedia.CMFormatDescription.MediaSubType
    public static let qualcomm: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegLayer1: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegLayer2: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegLayer3: CoreMedia.CMFormatDescription.MediaSubType
    public static let timeCode: CoreMedia.CMFormatDescription.MediaSubType
    public static let midiStream: CoreMedia.CMFormatDescription.MediaSubType
    public static let parameterValueStream: CoreMedia.CMFormatDescription.MediaSubType
    public static let appleLossless: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_HE: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_LD: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_ELD: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_ELD_SBR: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_ELD_V2: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_HE_V2: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_Spatial: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegD_USAC: CoreMedia.CMFormatDescription.MediaSubType
    public static let amr: CoreMedia.CMFormatDescription.MediaSubType
    public static let amr_WB: CoreMedia.CMFormatDescription.MediaSubType
    public static let audible: CoreMedia.CMFormatDescription.MediaSubType
    public static let iLBC: CoreMedia.CMFormatDescription.MediaSubType
    public static let dviIntelIMA: CoreMedia.CMFormatDescription.MediaSubType
    public static let microsoftGSM: CoreMedia.CMFormatDescription.MediaSubType
    public static let aes3: CoreMedia.CMFormatDescription.MediaSubType
    public static let enhancedAC3: CoreMedia.CMFormatDescription.MediaSubType
    public static let flac: CoreMedia.CMFormatDescription.MediaSubType
    public static let opus: CoreMedia.CMFormatDescription.MediaSubType
    public static let aacLCProtected: CoreMedia.CMFormatDescription.MediaSubType
    public static let aacAudibleProtected: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_32ARGB: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_32BGRA: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_24RGB: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16BE555: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16BE565: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16LE555: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16LE565: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16LE5551: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr8: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr8_yuvs: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_444YpCbCr8: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_4444YpCbCrA8: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr16: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr10: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_444YpCbCr10: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_8IndexedGray_WhiteIsZero: CoreMedia.CMFormatDescription.MediaSubType
    public static let animation: CoreMedia.CMFormatDescription.MediaSubType
    public static let cinepak: CoreMedia.CMFormatDescription.MediaSubType
    public static let jpeg: CoreMedia.CMFormatDescription.MediaSubType
    public static let jpeg_OpenDML: CoreMedia.CMFormatDescription.MediaSubType
    public static let sorensonVideo: CoreMedia.CMFormatDescription.MediaSubType
    public static let sorensonVideo3: CoreMedia.CMFormatDescription.MediaSubType
    public static let h263: CoreMedia.CMFormatDescription.MediaSubType
    public static let h264: CoreMedia.CMFormatDescription.MediaSubType
    public static let hevc: CoreMedia.CMFormatDescription.MediaSubType
    public static let hevcWithAlpha: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4Video: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg2Video: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg1Video: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcNTSC: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPAL: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcProPAL: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPro50NTSC: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPro50PAL: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD720p60: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD720p50: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080i60: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080i50: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080p30: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080p25: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes4444XQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes4444: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422HQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422LT: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422Proxy: CoreMedia.CMFormatDescription.MediaSubType
    public static let proResRAW: CoreMedia.CMFormatDescription.MediaSubType
    public static let proResRAWHQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg1System: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg2Transport: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg2Program: CoreMedia.CMFormatDescription.MediaSubType
    public static let dv: CoreMedia.CMFormatDescription.MediaSubType
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
    public static let embeddedDeviceScreenRecording: CoreMedia.CMFormatDescription.MediaSubType
    public static let cea608: CoreMedia.CMFormatDescription.MediaSubType
    public static let cea708: CoreMedia.CMFormatDescription.MediaSubType
    public static let atsc: CoreMedia.CMFormatDescription.MediaSubType
    public static let qt: CoreMedia.CMFormatDescription.MediaSubType
    public static let mobile3GPP: CoreMedia.CMFormatDescription.MediaSubType
    public static let webVTT: CoreMedia.CMFormatDescription.MediaSubType
    public static let timeCode32: CoreMedia.CMFormatDescription.MediaSubType
    public static let timeCode64: CoreMedia.CMFormatDescription.MediaSubType
    public static let counter32: CoreMedia.CMFormatDescription.MediaSubType
    public static let counter64: CoreMedia.CMFormatDescription.MediaSubType
    public static let icy: CoreMedia.CMFormatDescription.MediaSubType
    public static let id3: CoreMedia.CMFormatDescription.MediaSubType
    public static let boxed: CoreMedia.CMFormatDescription.MediaSubType
    public static let emsg: CoreMedia.CMFormatDescription.MediaSubType
    public static let tbgr: CoreMedia.CMFormatDescription.MediaSubType
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias RawValue = Swift.UInt32
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias _ObjectiveCType = Foundation.NSNumber
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func equalTo(_ otherFormatDescription: CoreMedia.CMFormatDescription, extensionKeysToIgnore: [CoreMedia.CMFormatDescription.Extensions.Key] = [], sampleDescriptionExtensionAtomKeysToIgnore: [Swift.String] = []) -> Swift.Bool
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var mediaType: CoreMedia.CMFormatDescription.MediaType {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var mediaSubType: CoreMedia.CMFormatDescription.MediaSubType {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var extensions: CoreMedia.CMFormatDescription.Extensions {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static func == (lhs: CoreMedia.CMFormatDescription, rhs: CoreMedia.CMFormatDescription) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var audioStreamBasicDescription: CoreAudioTypes.AudioStreamBasicDescription? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func withMagicCookie<R>(_ body: (Swift.UnsafeRawBufferPointer?) throws -> R) rethrows -> R
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var magicCookie: Foundation.Data? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var audioChannelLayout: CoreAudio.ManagedAudioChannelLayout? {
    get
  }
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var audioFormatList: [CoreAudioTypes.AudioFormatListItem] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var richestDecodableFormat: CoreAudioTypes.AudioFormatListItem? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var mostCompatibleFormat: CoreAudioTypes.AudioFormatListItem? {
    get
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  public struct EqualityMask : Swift.OptionSet, Swift.Sendable {
    public let rawValue: CoreMedia.CMAudioFormatDescriptionMask
    public init(rawValue: CoreMedia.CMAudioFormatDescriptionMask)
    public static let streamBasicDescription: CoreMedia.CMFormatDescription.EqualityMask
    public static let magicCookie: CoreMedia.CMFormatDescription.EqualityMask
    public static let channelLayout: CoreMedia.CMFormatDescription.EqualityMask
    public static let extensions: CoreMedia.CMFormatDescription.EqualityMask
    public static let all: CoreMedia.CMFormatDescription.EqualityMask
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias ArrayLiteralElement = CoreMedia.CMFormatDescription.EqualityMask
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Element = CoreMedia.CMFormatDescription.EqualityMask
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias RawValue = CoreMedia.CMAudioFormatDescriptionMask
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func equalTo(_ otherFormatDescription: CoreMedia.CMAudioFormatDescription, equalityMask: CoreMedia.CMFormatDescription.EqualityMask = .all) -> (Swift.Bool, equalityMask: CoreMedia.CMFormatDescription.EqualityMask)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct ParameterSetCollection : Swift.RandomAccessCollection {
    public typealias Element = Foundation.Data
    public typealias Index = Swift.Int
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(position: Swift.Int) -> Foundation.Data {
      get
    }
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Indices = Swift.Range<CoreMedia.CMFormatDescription.ParameterSetCollection.Index>
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMFormatDescription.ParameterSetCollection>
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias SubSequence = Swift.Slice<CoreMedia.CMFormatDescription.ParameterSetCollection>
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription.ParameterSetCollection : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var nalUnitHeaderLength: Swift.Int? {
    get
  }
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var parameterSets: CoreMedia.CMFormatDescription.ParameterSetCollection {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var dimensions: CoreMedia.CMVideoDimensions {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func presentationDimensions(usePixelAspectRatio: Swift.Bool = true, useCleanAperture: Swift.Bool = true) -> CoreFoundation.CGSize
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func cleanAperture(originIsAtTopLeft: Swift.Bool) -> CoreFoundation.CGRect
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public static var extensionKeysCommonWithImageBuffers: [CoreMedia.CMFormatDescription.Extensions.Key] {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func matchesImageBuffer(_ imageBuffer: CoreVideo.CVImageBuffer) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
  public var tagCollections: [[CoreMedia.CMTag]]? {
    get
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
  public func matchesTaggedBufferGroup(_ taggedBuffers: [CoreMedia.CMTaggedBuffer]) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func displayFlags() throws -> CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func justification() throws -> (horizontal: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification, vertical: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func defaultTextBox(originIsAtTopLeft: Swift.Bool, heightOfTextTrack: CoreFoundation.CGFloat) throws -> CoreFoundation.CGRect
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func defaultStyle() throws -> (localFontID: Swift.Int, bold: Swift.Bool, italic: Swift.Bool, underline: Swift.Bool, fontSize: CoreFoundation.CGFloat, colorComponents: [CoreFoundation.CGFloat])
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func fontName(localFontID: Swift.Int) throws -> Swift.String
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct TimeCode : Swift.Sendable {
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
    public struct Flag : Swift.OptionSet, Swift.Sendable {
      public let rawValue: Swift.UInt32
      public init(rawValue: Swift.UInt32)
      public static let dropFrame: CoreMedia.CMFormatDescription.TimeCode.Flag
      public static let twentyFourHourMax: CoreMedia.CMFormatDescription.TimeCode.Flag
      public static let negTimesOK: CoreMedia.CMFormatDescription.TimeCode.Flag
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
      public typealias ArrayLiteralElement = CoreMedia.CMFormatDescription.TimeCode.Flag
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
      public typealias Element = CoreMedia.CMFormatDescription.TimeCode.Flag
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
      public typealias RawValue = Swift.UInt32
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var frameDuration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var frameQuanta: Swift.UInt32 {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var timeCodeFlags: CoreMedia.CMFormatDescription.TimeCode.Flag {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMFormatDescription {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func keyWithLocalID(_ localKeyID: Darwin.OSType) -> [Swift.String : CoreFoundation.CFPropertyList]?
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var identifiers: [Swift.String] {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer {
  public struct SampleAttachments : Swift.Sendable, Swift.Equatable {
    public init(_ dictionaryRepresentation: [Swift.String : any Swift.Sendable] = [:])
    public var dictionaryRepresentation: [Swift.String : any Swift.Sendable] {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public subscript(rawAttachment key: Swift.String) -> (any Swift.Sendable)? {
      get
      set
    }
    #endif
    public var isNotSync: Swift.Bool {
      get
      set
    }
    public var isPartialSync: Swift.Bool {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var hasRedundantCoding: Swift.Bool? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var isDependedOnByOthers: Swift.Bool? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var dependsOnOthers: Swift.Bool? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var earlierDisplayTimesAllowed: Swift.Bool? {
      get
      set
    }
    #endif
    public var displayImmediately: Swift.Bool {
      get
      set
    }
    public var doNotDisplay: Swift.Bool {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var hevcTemporalInfo: CoreMedia.CMSampleBuffer.HEVCTemporalInfo? {
      get
      set
    }
    #endif
    public var hevcTemporalSubLayerAccess: Swift.Bool {
      get
      set
    }
    public var hevcStepwiseTemporalSubLayerAccess: Swift.Bool {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var hevcSyncSampleNALUnitType: Swift.Int? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var audioIndependentSampleDecoderRefreshCount: Swift.Int? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var cryptorSubsampleAuxiliaryData: Foundation.Data? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var hdr10PlusPerFrameData: Foundation.Data? {
      get
      set
    }
    #endif
    public static func == (a: CoreMedia.CMSampleBuffer.SampleAttachments, b: CoreMedia.CMSampleBuffer.SampleAttachments) -> Swift.Bool
  }
  public struct HEVCTemporalInfo : Swift.Equatable, Swift.Sendable {
    public var temporalLayerID: Swift.Int
    public var profileSpace: Swift.Int
    public var tierFlag: Swift.Int
    public var profileIndex: Swift.Int
    public var profileCompatibilityFlags: Foundation.Data?
    public var constraintIndicatorFlags: Foundation.Data?
    public var levelIndex: Swift.Int
    #if compiler(>=5.3) && $NonescapableTypes
    public init(temporalLayerID: Swift.Int, profileSpace: Swift.Int, tierFlag: Swift.Int, profileIndex: Swift.Int, profileCompatibilityFlags: Foundation.Data?, constraintIndicatorFlags: Foundation.Data?, levelIndex: Swift.Int)
    #endif
    public static func == (a: CoreMedia.CMSampleBuffer.HEVCTemporalInfo, b: CoreMedia.CMSampleBuffer.HEVCTemporalInfo) -> Swift.Bool
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer {
  public struct SampleProperties : Swift.Sendable, Swift.Equatable {
    public var size: Swift.Int?
    public var timing: CoreMedia.CMSampleTimingInfo
    public var attachments: CoreMedia.CMSampleBuffer.SampleAttachments
    #if compiler(>=5.3) && $NonescapableTypes
    public init(size: Swift.Int? = nil, timing: CoreMedia.CMSampleTimingInfo, attachments: CoreMedia.CMSampleBuffer.SampleAttachments = .init())
    #endif
    public static func == (a: CoreMedia.CMSampleBuffer.SampleProperties, b: CoreMedia.CMSampleBuffer.SampleProperties) -> Swift.Bool
  }
  public enum SizePerSample : Swift.Sendable {
    case distinct([Swift.Int])
    case uniform(Swift.Int)
  }
  public enum TimingPerSample : Swift.Sendable {
    case distinct([CoreMedia.CMSampleTimingInfo])
    case sequential(startingAt: CoreMedia.CMSampleTimingInfo)
    @inlinable public static func sequential(presentationTimeOfFirstSample: CoreMedia.CMTime, uniformDuration: CoreMedia.CMTime, decodeTimeOfFirstSample: CoreMedia.CMTime = .invalid) -> CoreMedia.CMSampleBuffer.TimingPerSample {
			.sequential(startingAt: .init(
				duration: uniformDuration,
				presentationTimeStamp: presentationTimeOfFirstSample,
				decodeTimeStamp: decodeTimeOfFirstSample
			))
		}
  }
  public struct SamplePropertiesCollection : Swift.Sendable, Swift.RandomAccessCollection, Swift.MutableCollection {
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Element = CoreMedia.CMSampleBuffer.SampleProperties
    public init()
    #if compiler(>=5.3) && $NonescapableTypes
    public init(sampleCount: Swift.Int, sizes: CoreMedia.CMSampleBuffer.SizePerSample?, timings: CoreMedia.CMSampleBuffer.TimingPerSample?, attachments: [CoreMedia.CMSampleBuffer.SampleAttachments]? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var sizes: CoreMedia.CMSampleBuffer.SizePerSample? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var timings: CoreMedia.CMSampleBuffer.TimingPerSample? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var attachments: [CoreMedia.CMSampleBuffer.SampleAttachments]? {
      get
      set
    }
    #endif
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public var count: Swift.Int {
      get
    }
    public subscript(position: Swift.Int) -> CoreMedia.CMSampleBuffer.SampleProperties {
      get
      set
    }
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMSampleBuffer.SamplePropertiesCollection>
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias SubSequence = Swift.Slice<CoreMedia.CMSampleBuffer.SamplePropertiesCollection>
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer.SizePerSample : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Swift.Int
  public init(arrayLiteral elements: CoreMedia.CMSampleBuffer.SizePerSample.ArrayLiteralElement...)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer.SizePerSample : Swift.Equatable {
  public static func == (lhs: CoreMedia.CMSampleBuffer.SizePerSample, rhs: CoreMedia.CMSampleBuffer.SizePerSample) -> Swift.Bool
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer.TimingPerSample : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = CoreMedia.CMSampleTimingInfo
  public init(arrayLiteral elements: CoreMedia.CMSampleBuffer.TimingPerSample.ArrayLiteralElement...)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer.TimingPerSample : Swift.Equatable {
  public static func == (lhs: CoreMedia.CMSampleBuffer.TimingPerSample, rhs: CoreMedia.CMSampleBuffer.TimingPerSample) -> Swift.Bool
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer.SamplePropertiesCollection : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = CoreMedia.CMSampleBuffer.SamplePropertiesCollection.Element
  @inlinable public init(arrayLiteral elements: CoreMedia.CMSampleBuffer.SamplePropertiesCollection.ArrayLiteralElement...) {
		self.init(elements)
	}
  public init(_ elements: some Collection<Element>)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMSampleBuffer.SamplePropertiesCollection : Swift.Equatable {
  public static func == (lhs: CoreMedia.CMSampleBuffer.SamplePropertiesCollection, rhs: CoreMedia.CMSampleBuffer.SamplePropertiesCollection) -> Swift.Bool
}
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTime {
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public init(seconds: Swift.Double, preferredTimescale: CoreMedia.CMTimeScale)
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public init(value: CoreMedia.CMTimeValue, timescale: CoreMedia.CMTimeScale)
}
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTime {
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isValid: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isPositiveInfinity: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isNegativeInfinity: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isIndefinite: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var isNumeric: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var hasBeenRounded: Swift.Bool {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public var seconds: Swift.Double {
    get
  }
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public func convertScale(_ newTimescale: Swift.Int32, method: CoreMedia.CMTimeRoundingMethod) -> CoreMedia.CMTime
}
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIME_IS_VALID(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIME_IS_INVALID(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIME_IS_POSITIVEINFINITY(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIME_IS_NEGATIVEINFINITY(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIME_IS_INDEFINITE(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIME_IS_NUMERIC(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
public func CMTIME_HAS_BEEN_ROUNDED(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTime {
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func + (addend1: CoreMedia.CMTime, addend2: CoreMedia.CMTime) -> CoreMedia.CMTime
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func - (minuend: CoreMedia.CMTime, subtrahend: CoreMedia.CMTime) -> CoreMedia.CMTime
}
@available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMTime : Swift.Equatable, Swift.Comparable {
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func < (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func <= (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func > (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func >= (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func == (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(macOS 10.7, iOS 4.0, tvOS 9.0, watchOS 6.0, visionOS 1.0, *)
  public static func != (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension CoreMedia.CMTime : Swift.Hashable {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol CMBlockBufferProtocol {
  var owner: CoreMedia.CMBlockBuffer { get }
  var startIndex: Swift.Int { get }
  var endIndex: Swift.Int { get }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Slice {
  }
}
@available(*, unavailable)
extension CoreMedia.CMBlockBuffer.Slice : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer.Slice : CoreMedia.CMBlockBufferProtocol {
  public var owner: CoreMedia.CMBlockBuffer {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer : CoreMedia.CMBlockBufferProtocol {
  public var owner: CoreMedia.CMBlockBuffer {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(bounds: Swift.ClosedRange<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(bounds: Swift.Range<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(bounds: Swift.PartialRangeUpTo<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(bounds: Swift.PartialRangeThrough<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(bounds: Swift.PartialRangeFrom<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public subscript(bounds: (Swift.UnboundedRange_) -> ()) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
public protocol _CMBlockBufferInitTrampoline : CoreMedia._CMInitTrampoline where Self.T == CoreMedia.CMBlockBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public typealias CustomBlockAllocator = (Swift.Int) -> Swift.UnsafeMutableRawPointer?
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public typealias CustomBlockDeallocator = (Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia._CMBlockBufferInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(capacity: Swift.Int = 0, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(buffer: Swift.UnsafeMutableRawBufferPointer, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(length: Swift.Int, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(buffer: Swift.UnsafeMutableRawBufferPointer, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init(length: Swift.Int, allocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockAllocator, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public init<T>(bufferReference: T, flags: CoreMedia.CMBlockBuffer.Flags = []) throws where T : CoreMedia.CMBlockBufferProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer : CoreMedia._CMBlockBufferInitTrampoline {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
  public typealias T = CoreMedia.CMBlockBuffer
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Error : Swift.Sendable {
    public static let structureAllocationFailed: Foundation.NSError
    public static let blockAllocationFailed: Foundation.NSError
    public static let badCustomBlockSource: Foundation.NSError
    public static let badOffsetParameter: Foundation.NSError
    public static let badLengthParameter: Foundation.NSError
    public static let badPointerParameter: Foundation.NSError
    public static let emptyBlockBuffer: Foundation.NSError
    public static let unallocatedBlock: Foundation.NSError
    public static let insufficientSpace: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public struct Flags : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public static let assureMemoryNow: CoreMedia.CMBlockBuffer.Flags
    public static let alwaysCopyData: CoreMedia.CMBlockBuffer.Flags
    public static let dontOptimizeDepth: CoreMedia.CMBlockBuffer.Flags
    public static let permitEmptyReference: CoreMedia.CMBlockBuffer.Flags
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias ArrayLiteralElement = CoreMedia.CMBlockBuffer.Flags
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias Element = CoreMedia.CMBlockBuffer.Flags
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, macOS 10.15, *)
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func makeContiguous(allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws -> CoreMedia.CMBlockBuffer
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func makeContiguous(allocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockAllocator, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws -> CoreMedia.CMBlockBuffer
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func append(length: Swift.Int, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func append(buffer: Swift.UnsafeMutableRawBufferPointer, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func append(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func append(length: Swift.Int, allocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockAllocator, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  #endif
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func append(buffer: Swift.UnsafeMutableRawBufferPointer, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func append(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func append<T>(bufferReference: T, flags: CoreMedia.CMBlockBuffer.Flags = []) throws where T : CoreMedia.CMBlockBufferProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func assureBlockMemory() throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func withContiguousStorage<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) throws -> R
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func dataBytes() throws -> Foundation.Data
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func copyDataBytes(to destination: Swift.UnsafeMutableRawBufferPointer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func replaceDataBytes(with sourceBytes: Swift.UnsafeRawBufferPointer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func fillDataBytes(with fillByte: Swift.UInt8) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public func withUnsafeMutableBytes<R>(atOffset offset: Swift.Int = 0, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) throws -> R
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var dataLength: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var isContiguous: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public var isEmpty: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
  public class var typeID: CoreFoundation.CFTypeID {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMAttachmentBearerAttachments.Mode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMAttachmentBearerAttachments.Mode : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, visionOS 1.0, *)
extension CoreMedia.CMAttachmentBearerAttachments.Mode : Swift.RawRepresentable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorVolume : Swift.BitwiseCopyable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.ContentColorVolume.ColorPrimaries : Swift.BitwiseCopyable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.AlgorithmKind : Swift.Equatable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.AlgorithmKind : Swift.Hashable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensRole : Swift.Equatable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensRole : Swift.Hashable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensDomain : Swift.Equatable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.LensDomain : Swift.Hashable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.ExtrinsicOriginSource : Swift.Equatable {}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value.CameraCalibrationDataLensCollection.ExtrinsicOriginSource : Swift.Hashable {}
